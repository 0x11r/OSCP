

---
# Web Exploits

- Does it initiate an HTTP or HTTPS connection?
- Does it access a specific web application path or route?
- Does the exploit leverage a pre-authentication vulnerability?
- If not, how does the exploit authenticate to the web application?
- How are the GET or POST requests crafted to trigger and exploit the vulnerability? Is there any HTTP method involved?
- Does it rely on default application settings (such as the web path of the application) that may have been changed after installation?
- Will oddities such as self-signed certificates disrupt the exploit?

We must also remember that public web application exploits do not take into account additional protections such as _.htaccess_[1](https://portal.offsec.com/courses/pen-200-44065/learning/fixing-exploits-45086/fixing-web-exploits-45121/fixing-web-exploits-45129#fn-local_id_73-1) files or _Web Application Firewalls_ (WAF). This is mainly because the exploit author cannot possibly know about all these protections during the development process, making them out of scope.



Moreover, the official documentation[3](https://portal.offsec.com/courses/pen-200-44065/learning/fixing-exploits-45086/fixing-web-exploits-45121/selecting-the-vulnerability-and-fixing-the-code-45093#fn-local_id_78-3) indicates that the SSL certificate will be ignored if we set the _verify_ parameter to "False".

```c
response  = requests.post(url, data=data, allow_redirects=False, verify=False)
response = requests.post(url, data=data, files=txt, cookies=cookies, verify=False)
response = requests.post(url, data=data, cookies=cookies, allow_redirects=False, verify=False)
```

change url , upload dir , username , password 

---
---
# Memory Exploits

- [ ] Try differnt exploits 

```c
GLIBC_2.34
```

one: compile a static binary `-static`

two: compile the same code without any changes in a docker container (Ubuntu 20.04 Image which is what Aero is running) 

three: change the code and include the headers that are missing as well as fixing execvp() issue which only recieves 2 arguments in the new version.

---

> Check the version of the GLIBC Library Files

```c
ldd --version
```


> 1. **Using `ldconfig` to Check GLIBC Library Files**

You can locate GLIBC library files and check their versions using `ldconfig`:

```c
ldconfig -p | grep libc.so.6
```

> This will show you the paths of `libc.so.6` (the GLIBC library). To check its version, run:

```c
/lib/x86_64-linux-gnu/libc.so.6
```

> compile with a specific version

> 1 : Download and extract GLIBC

```c
wget http://ftp.gnu.org/gnu/libc/glibc-2.28.tar.gz 
tar -zxvf glibc-2.28.tar.gz 
cd glibc-2.28
```

> 2 : build and install GLIBC to a specific directory

```c
mkdir build
cd build
../configure --prefix=/opt/glibc-2.28
make -j4
make install
```

> 3 : compile using gcc with custom GLIBC Version

> 3.1.1 **Set the Environment Variables**:

```c
export LD_LIBRARY_PATH=/opt/glibc-2.28/lib:$LD_LIBRARY_PATH
export C_INCLUDE_PATH=/opt/glibc-2.28/include:$C_INCLUDE_PATH
export LIBRARY_PATH=/opt/glibc-2.28/lib:$LIBRARY_PATH
```

> 3.1.2 Compile with `gcc` 

Now, when you run `gcc`, it will use the headers and libraries from `/opt/glibc-2.28`:

```c
gcc -o your_program your_program.c
```

> 3.2 confirm the Linked GLIBC version

> 3.2.1 use `ldd` on the compiled binary

```c
ldd your_program
```

3.3 Run the program using the custom GLIBC Version

```c
LD_LIBRARY_PATH=/opt/glibc-2.28/lib ./your_program
```

---
---
